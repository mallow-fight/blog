---
title: 异步
order: 3
type: special
---

> [参考](https://github.com/getify/You-Dont-Know-JS/blob/master/preface.md)

## 概念

### 事件轮询

- js并没有异步的概念，所看到的异步只不过是代码块的一段段执行，随着时间推移，也就有了所谓的异步

- js是单线程的，轮询队列中的事件会一个个被执行，setTimeout不会一开始就把回调放入轮询队列中，而是到了指定的时间之后会将回调放入轮询队列中，如果此时轮询队列中有了多个事件，它会排在这些事件之后执行，这也会导致定时器没那么准时

- 直到最近，这种情况才发生了改变，es6现在明确指出了事件轮询应当如何工作，而不是取决于宿主环境

### Jobs

- 稍后，但尽快

- 模拟代码
```js
console.log('A');
setTimeout( function(){
  console.log('B');
}, 0);
// 理论上的 'Job Api'
schedule( function() {
  console.log('C');
  schedule(function() {
    console.log('D');
  })
})
```

- expected：ABCD
- actual：ACDB

- 因为Job发生在当前的事件轮询tick的末尾，而定时器会在下一个事件轮询tick触发
- Promises的异步行为基于Job的，所以搞明白它与事件轮询行为的联系是很重要的

### 总结

- 一个JS程序总是被打断为两个或更多的代码块儿，第一个代码块儿现在运行，下一个代码块儿稍后运行，来响应一个事件。虽然程序是一块儿一块儿被执行的，但它们都共享相同的程序作用域和状态，所以对状态的每次修改都是在前一个状态之上的。

- 不论何时有事件要运行，事件轮询将运行至队列为空。事件轮询的每次迭代称为一个tick。用户交互，IO，和定时器会将事件在事件队列中排队。

- 在任意给定的时刻，一次只有一个队列中的事件可以被处理。当事件执行时，他可以直接或间接地导致一个或更多的后续事件。

- 并发是当两个或多个事件链条随着事件相互穿插，因此从高层的角度来看，它们在同时运行（即便在给定的某一时刻只有一个事件在被处理）。

- 在这些并发进程之间进行某种形式的互动协调通常是有必要的，比如保证顺序或防止竞合状态。这些进程还可以协作：通过将它们自己打断为小的代码块儿来允许其他进程穿插。

## 回调

- 回调是JS中异步的基础单位，但是随着JS的成熟，它们对于异步编程的演化趋势来讲显得不够。

- 我们的大脑用顺序的，阻塞的，单线程的语义方式规划事情，但是回调使用非线性，非顺序的方式表达异步流程，这使得我们正确推理这样的代码变得非常困难。不好推理的代码是容易导致bug。

- 回调遭受着控制反转的蹂躏，它们隐含地将控制权交给第三方（通常第三方工具不受你控制）来调用程序的延续。这种控制权的转移使我们得到一张信任问题的令人不安的列表，比如回调是否会比我们期望的被调用更多次。

- 制造特殊的逻辑来解决这些信任问题是可能的，但是它比它应有的难度高多了，还会产生更笨重和更难维护的代码，而且在bug实际咬到你的时候代码会显得在这些危险上被保护的不够。

- 我们需要一个所有这些信任问题的一般化解决方案。一个可以被所有我们制造的回调复用，而且没有多余的模版代码负担的方案。

## Promises

