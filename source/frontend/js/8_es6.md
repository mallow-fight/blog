---
title: es6
order: 8
type: js
---

## let和const

### let

- let所声明的变量，只在let命令所在的代码块内有效

- for循环
  - 如果使用var声明i，由于全局只有一个变量i，会导致每次循环引用的变量i都是同一个，这个仅限于循环内部有函数引用或者有延时操作，正常函数内部打印i还是ok的，例子：
  ```js
  var a = []
  for(var i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i)
    }
    console.log(i) // 0 ~ 9
  }
  a[9]() // 10
  i // 10：因为要做 i < 10 的判断，所以i肯定是10
  ```
  - 如果使用let，声明的变量仅在块级作用域内有效，每一次循环都是一个新的变量。js引擎内部会记住上一轮循环的值，初始化本轮变量i时，就是在上一轮循环的基础上进行计算
  - 特殊之处：设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域
  ```js
  for(let i = 0; i < 3; i++) {
    // console.log(i) i is not defined
    let i = 'mallow'
    console.log(i) // mallow
  }
  ```

- 不存在变量提升：使用var会发生变量提升的现象，值为undefined，let改变了语法行为，它所声明的对象一定要在声明后使用

- 暂时性死区：只要块级作用域内存在let或const命令，它所声明的变量就绑定了这个区域，不再受外部的影响，同上面的for循环特殊之处
```js
var tmp = 123
if (true) {
  tmp = 'abc' // ReferenceError: tmp is not defined
  let tmp
}
```

- 不允许重复声明
```js
function func(arg) {
  let arg // SyntaxError: Identifier 'arg' has already been declared
}
function func(arg) {
  {
    let arg
  }
}
```

### 块级作用域

- es5只有全局作用域和函数作用域，没有块级作用域，带来的不合理场景：
  - 内层变量可能会覆盖外层变量：变量提升导致的
  ```js
  var tmp = new Date()
  function f() {
    console.log(tmp)
    if(false) {
      var tmp = 'hello world'
    }
  }
  f()
  ```
  - 用来计数的循环变量泄漏为全局变量
  ```js
  var s = 'hello'
  for(var i = 0; i < s.length; i++) {
    console.log(s[i])
  }
  console.log(i)
  ```

- es6的块级作用域
  - let实际上为js新增了块级作用域
  - 允许块级作用域的任意嵌套
  - 内层作用域可以定义外层作用域的同名变量
  - 块级作用域的出现，实际上使得广泛应用的立即执行函数表达式（IIFE）不再必要了
  ```js
  // IIFE 写法
  (function () {
    var tmp = 'xxx'
  }())

  // 块级作用域写法
  {
    let tmp = 'xxx'
  }
  ```

### 块级作用域和函数声明

- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

### const

- 声明一个只读的常量，一旦声明，值就不能改变

- 作用域和let相同：只在声明所在的块级作用域内有效

- 声明的常量也不提升，同样存在暂时性死区

- 不可重复声明

#### 本质

- const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量

- 对于复合类型的数据（数组、对象），变量指向的是内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
  - 如果真想将对象冻结，应该使用Object.freeze方法：
  ```js
  const foo = Object.freeze({})
  // 常规模式时，下面一行不起作用
  // 严格模式时，该行会报错
  foo.prop = 123
  ```
  - 除了将对象本身冻结，对象的属性也应该被冻结，如：
  ```js
  function freeze(obj) {
    Object.freeze(obj)
    Object.keys(obj).forEach(key => {
      if(typeof obj[key] === 'object') {
        freeze(obj[key])
      }
    })
  }
  ```

### 声明对象的六种方法

- es5声明变量的方法：var、function
- es6：let、const、import、class

### 顶层对象的属性

- 在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性和全局变量是等价的

- ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定：let、const、class命令声明的全局对象，不属于顶层对象的属性。全局变量将逐步和顶层对象的属性脱钩

### global对象

- 不同环境的global对象不一样，垫片库 system.global 模拟了这个提案，可以在所有环境拿到global

## 变量的解构赋值

### 数组

```js
// before
let a = 1
let b = 2
let c = 3

// now
let [a, b, c] = [1, 2, 3]
```

#### 模式匹配

```js
let [a, [b, c]] = [1, [2, 3]]
let [ , , e] = [1, 2, 3]
let [f, , g] = [1, , 3]
let [h, ...j] = [1, 2, 3, 4] // j: [2, 3, 4]
let [x, y, ...z] = [1] // x: 1; y: undefined; z: []
```

#### 不完全解构

```js
let [x, y] = [1, 2, 3]
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4]
a // 1
b // 2
d // 4
```

#### 不可遍历结构

```js
// 报错
let [foo] = 1
let [foo] = false
let [foo] = NaN
let [foo] = undefined
let [foo] = null
let [foo] = {}
```

#### Set结构

```js
let [x, y, z] = new Set(['a', 'b', 'c'])
x // 'a'

// 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs() {
  let a = 0
  let b = 1
  while (true) {
    yield a; // 这个地方必须要有分号
    [a, b] = [b, a + b];
  }
}
let [one, two, three, four, five, six] = fibs()
six // 5
```

#### 默认值

```js
let [foo = true] = []
foo // true
let [x, y = 'b'] = ['a'] // x: a; y: b
let [x, y = 'b'] = ['a', undefined] // x: a; y: b
// 只有undefined，默认值才生效
let [x = 1] = [null] // x: null

// 默认值是表达式
function f() {
  console.log('aaa')
}
let [x = f()] = [1] // 因为x能取到值，所以表达式是惰性求值的，即只有在用到的时候才会求值
```

#### 引用其他变量

> 变量必须提前声明

```js
let [x = 1, y = x] = [] // x: 1; y: 1
let [x = 1, y = x] = [2] // x: 2; y: 2
let [x = 1, y = x] = [1, 2] // x: 1; y: 2
let [x = y, y = 1] = [] // ReferenceError: y is not defined
```

### 对象

- 数组元素是按次序排列的，变量取值由它的位置决定的；而对象的属性没有次序，变量必须和属性同名，才能取到正确的值
```js
let {bar, foo, baz} = { foo: 'aaa', bar: 'bbb' }
foo // aaa
bar // bbb
baz // undefined
```

#### 变量名和属性名不一致

```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // 'aaa'

let obj = { first: 'hello', last: 'world' }
let { first: f, last: l } = obj
f // 'hello'
l // 'world'
```

- 实际上，对象的解构赋值是下面形式的简写
```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }
```

- 也就是说，是先找到同名属性，然后再赋值给对应的变量。
```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // aaa
foo // error: foo is not defined
```

#### 嵌套结构的对象

```js
let obj = {
  p: [
    'hello',
    { y: 'World' }
  ]
}
let { p: [x, { y }] } = obj
x // 'Hello'
y // 'World'

// 将p作为变量赋值
let { p, p: [x, { y }] } = obj
x // Hello
y // World
p // [Hello, {y: World}]

// 解构到对象或数组
let obj = {}
let arr = []
// 这个地方必要要有()，避免js将其解释为代码块
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true })
obj // {prop: 123}
arr // [true]
```

#### 默认值

- 同样：默认值生效的条件是，对象的属性值严格等于undefined

```js
let {x = 3} = {}
let {x: y = 4} = {x: 5} // y: 5
```

#### 对数组进行对象属性的解构

```js
let arr = [1, 2, 3]
let {0: first, [arr.length - 1] : last} = arr
first // 1
last // 3
```

### 字符串

```js
const [a, b, c, d, e] = 'hello'
a // h
b // e
c // l
d // l
e // o

let {length: len} = 'hello'
len // 5
```

### 数值和布尔值

```js
let {toString: s} = 123
s === Number.prototype.toString // true
let {toString: s} = true
s === Boolean.prototype.toString // true

let { prop: x } = undefined // TypeError
let { prop: y } = null // TypeError
```

### 函数参数

```js
function add([x, y]) {
  return x + y
}
add([1, 2]) // 3

function move({x = 0, y = 0} = {}) {
  return [x, y]
}
move({x: 3, y: 8}) // [3, 8]
move({x: 3}) // [3, 0]
move({}) // [0, 0]
move() // [0, 0]
```

### 圆括号

- 尽量不要使用圆括号

- 可以使用圆括号的情况只有一种：赋值语句的非模式部分
```js
[(b)] = [3]
({ p: (d) } = {})
[(parseInt.prop)] = [3]
```

### 用途

- 交换变量的值
```js
let x = 1
let y = 2
[x, y] = [y, x]
```

- 从函数返回多个值
```js
function example() {
  return [1, 2, 3]
}
let [a, b, c] = example()

function exmaple() {
  return {
    foo: 1,
    bar: 2
  }
}
let { foo, bar } = exmaple()
```

- 函数参数的定义
```js
// 参数是一组有次序的值
function f([x, y, z]) {}
f([1, 2, 3])

// 参数是一组无次序的值
function f({x, y, z}) {}
f({z: 3, y: 2, x: 1})
```

- 提取JSON数据
```js
let json = {
  id: 42,
  status: 'ok',
  data: [111, 222]
}
let { id, status, data: numbers } = json
console.log(id, status, numbers)
```

- 函数参数的默认值
```js
function foo(a = 1, b = 2, c = false) {}
```

- 遍历Map解构：任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map解构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便
```js
const map = new Map()
map.set('first', 'hello')
map.set('second', 'world')
for(let [key, value] of map) {
  console.log(key + ' is ' + value)
}
for(let [key] of map) {}
for(let [, value] of map) {}
```

### 输入模块的制定方法
```js
const { a, b } = require('ModuleName')
```

## 字符串的扩展

### Unicode表示法

- js允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点

- 这种表示法只限于码点在\u0000~\uFFFF之间的字符，超出这个范围的字符，必须用两个双字节的形式表示

```js
"\u0061" // "a"

"\uD842\uDFB7" // 𠮷

"\u20BB7" // " 7" js会理解成\u20BB+7
```

- es6的改进：只要将码点放入大括号，就能正确解读该字符

```js
"\u{20BB7}" // "𠮷"
"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

- 6中方法表示一个字符

```js
'\z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

### codePointAt

```js
var s = "𠮷";

s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```

```js
let s = '𠮷a';

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97

// 十六进制的值
let s = '𠮷a';

s.codePointAt(0).toString(16) // "20bb7"
s.codePointAt(2).toString(16) // "61"

let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61

function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}

is32Bit("𠮷") // true
is32Bit("a") // false
```

### String.fromCodePoint

```js
String.fromCharCode(0x20BB7)
// "ஷ"

String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
```

### 遍历器接口

```js
for (let codePoint of 'foo') {
  console.log(codePoint)
}
// "f"
// "o"
// "o"

let text = String.fromCodePoint(0x20BB7);

for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "

for (let i of text) {
  console.log(i);
}
// "𠮷"
```

### normalize

```js
'\u01D1'==='\u004F\u030C' //false

'\u01D1'.length // 1
'\u004F\u030C'.length // 2

// 用来将字符的不同表示方法统一为同样的形式，称为Unicode正规化
'\u01D1'.normalize() === '\u004F\u030C'.normalize()
// true
```

- normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。
  - NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
  - NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
  - NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
  - NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
  ```js
  '\u004F\u030C'.normalize('NFC').length // 1
  '\u004F\u030C'.normalize('NFD').length // 2
  ```

### includes()、startsWith()、endsWith()

- includes(): 返回布尔值，表示是否找到了参数字符串
- startsWith(): 返回布尔值，表示参数字符串是否在原字符串的头部
- endsWith(): 返回布尔值，表示参数字符串是否在原字符串的尾部

```js
let s = 'Hello world!'
s.startsWidth('Hello') // true
s.endsWith('!') // true
s.includes('o') // true

// 支持第二个参数，表示开始搜索的位置
let s = 'Hello world!';
s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
```

### repeat()

- 返回一个新字符串，表示将原字符串重复n次
```js
'x'.repeat(3) // 'xxx'
'hello'.repeat(2) // 'hellohello'
'na'.repeat(0) // ''
'na'.repeat(2.9) // 'nana'
'na'.repeat(Infinity) // RangeError
'na'.repeat(-1) // RangeError
'na'.repeat(-0.9) // ''
'na'.repeat(NaN) // ''
'na'.repeat('na') // ''
'na'.repeat('3') // 'nanana'
```

### padStart()、padEnd()

- es2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全

```js
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'

'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'

'abc'.padStart(10, '0123456789') // '0123456abc'

'x'.padStart(4) // '    x'
'x'.padEnd(4) // 'x    '

// 用途：为数值补全指定位数
'1'.padStart(10, '0') // '0000000001'
'12'.padStart(10, '0') // '0000000012'
'123456'.padStart(10, '0') // '0000123456'

// 用途：提示字符串格式
'12'.padStart(10, 'YYYY-MM-DD') // 'YYYY-MM-12'
'09-12'.padStart(10, 'YYYY-MM-DD') // 'YYYY-09-12'
```

### matchAll()

- 返回一个正则表达式在当前字符串的所有匹配

### 模版字符串

```js
// 所有的空格和缩进都会被保留在输出之中
`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`
// 如果不想用<ul>标签前面的换行，可以使用trim方法消除它
```

- 需要将变量名写在`${}`之中

- 还能嵌套：
```js
`${`${var2}`var1}`
```

### 模版编译

- [vue和react都有使用](http://es6.ruanyifeng.com/#docs/string#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91)

### 标签模版

```js
alert`123`
// 等同于
alert(123)

let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);

function tag(stringArr, value1, value2){
  // ...
}

// 等同于

function tag(stringArr, ...values){
  // ...
}
```

## RegExp构造函数

- [参考地址](http://es6.ruanyifeng.com/#docs/regex)

## 数值的扩展

- [参考地址](http://es6.ruanyifeng.com/#docs/number)

### Number.isFinite()，Number.isNaN()

- 和传统的全局方法isFinite()和isNaN的区别：传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false，Number.isNaN()对NaN返回true，非NaN一律返回false

```js
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
Number.isNaN(1) // false
```

### Number.isInteger()

- 用来判断一个数值是否为整数
```js
Number.isInteger(25) // true
Number.isInteger(25.1) // false
Number.isInteger(25.0) // false
Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
Number.isInteger(3.0000000000000002) // true
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```

### Math对象的扩展

#### Math.trunc()
- 去除一个数的小数部分，返回整数部分
```js
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
```

- 对于非数值，内部会使用Number方法将其先转为数值
```js
Math.trunc('123.456') // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
```

- 对于空值和无法截取整数的值，返回NaN
```js
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
```

#### Math.sign()

- 用来判断一个数到底是正数、负数还是零。对于非数值，会先将其转换为数值
  - 参数为正数，返回+1
  - 参数为负数，返回-1
  - 参数为0，返回0
  - 参数为-0，返回-0
  - 其他值，返回NaN

```js
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN

Math.sign('')  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign('9')  // +1
Math.sign('foo')  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
```

#### 指数运算符

```js
2 ** 2 // 4
2 ** 3 // 8

2 ** 3 ** 2 // 相当于 2 ** (3 ** 2) = 512
```

## 函数的扩展

### 参数的默认值

```js
// before es6
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World

// after es6
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Point();
p // { x: 0, y: 0 }
```

- 阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档
- 有利于将来的代码优化，即使未来版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行

- 参数变量是默认声明的，所以不能用let或const再次声明。

```js
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

- 使用参数默认值时，函数不能有同名参数。

```js
// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
```

- 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
```

- 和解构赋值默认值结合使用

```js
function foo({x, y = 5}) {
  console.log(x, y)
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError

function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5

function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}

fetch('http://example.com', {})
// "GET"

fetch('http://example.com')
// 报错

function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
// "GET"
```

- 练习
```js
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

- 参数默认值的位置
```js
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]

function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
```

### length属性

- 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真

### 作用域

```js
// example-1
var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2

// example-2
let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1

// example-3
function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // ReferenceError: x is not defined

// example-4
var x = 1;

function foo(x = x) {
  // ...
}

foo() // ReferenceError: x is not defined

// example-5
let foo = 'outer';

function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar(); // outer

// example-6
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar() // ReferenceError: foo is not defined

// example-7
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}

foo() // 3
x // 1

// example-8
var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}

foo() // 2
x // 1

// 指定某一个参数不得省略，如果省略就抛出一个错误
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter

// 将参数默认值设为undefined，表明这个参数可以省略的
function foo(optional = undefined) { ··· }
```

### rest参数

- 用于获取函数的多余参数，这样就不需要使用arguments对象了，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中
```js
function add(...values) {
  let sum = 0
  for (var val of values) {
    sum += val
  }
  return sum
}
add(2, 5, 3) // 10
```

- example:
```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();

function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```

- rest参数之后不能再有其他参数
```js
// 报错
function f(a, ...b, c) {
  // ...
}
```

- 函数的length属性，不包括rest参数
```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

### 严格模式

- 从es5开始，函数内部可以设定为严格模式

- es6做了一点修改，规定只要函数参数使用了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

### name属性

- 函数的name属性，返回该函数的函数名

```js
function foo() {}
foo.name // 'foo'

var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"

const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"

(new Function).name // "anonymous"

function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
```

### 箭头函数

- 基本用法

```js
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};

var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};

var sum = (num1, num2) => { return num1 + num2; }

// 报错
let getTempItem = id => { id: id, name: "Temp" };

// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });

let foo = () => { a: 1 };
foo() // undefined

// 箭头函数只有一行语句，且不需要返回值
let fn = () => void doesNotReturn();

const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}

const isEven = n => n % 2 == 0;
const square = n => n * n;

// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) => a - b);

const numbers = (...nums) => nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) => [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
```

#### 注意点

- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，不能使用call、apply、bind这些方法去改变this的指向

- 不可以当作构造函数，也就是说不可以使用new命令，否则会抛出一个错误

- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。也不存在super、new.target

- 不可以使用yield命令，因此箭头函数不能用作Generator函数

### 双冒号运算符

```js
foo::bar
// 等同于
bar.bind(foo)

foo::bar(...arguments)
// 等同于
bar.apply(foo, arguments)
```

### 尾调用优化

> es6的尾递归优化只在严格模式下开启，正常模式是无效的，因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈：func.arguments、func.caller

- 是函数式编程的一个重要概念，指某个函数的最后一步是调用另一个函数
```js
function f(x) {
  return g(x)
}
```

- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

- 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”
```js
function addOne(a) {
  var one = 1
  function inner(b) {
    return b + one
  }
  return inner(a)
}
```

- 非尾递归的 Fibonacci 数列实现如下。
```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
```

- 尾递归优化过的 Fibonacci 数列实现如下。
```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

- es6第一次明确规定，所有ECMAScript的实现，都必须部署尾递归，这样就不会发生栈溢出，相对节省内存。

- 函数柯里化
```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120

// 采用es6的函数默认值
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

#### 尾递归优化的实现

- 蹦床函数
```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f()
  }
  return f
}
```

- 真正的实现
```js
function tco(f) {
  var value
  var active = false
  var accumulated = []
  return function accumulator() {
    accumulated.push(arguments)
    if(!active) {
      active = false
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift())
      }
      active = false
      return value
    }
  }
}

var sum = tco(function(x, y) {
  if(y > 0) {
    return sum(x + 1, y -1)
  } else {
    return x
  }
})

sum(1, 100000)
```

- 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

## 数组的扩展

### 扩展运算符

```js
...[1, 2, 3]
// 1 2 3

// 函数调用
function push(array, ...items) {
  array.push(...items)
}

function add(x, y) {
  return x + y
}

const numbers = [4, 38]
add(...numbers) // 42
```

- 该方法可以替代函数的apply方法

- 应用
```js
// 复制数组，是一种浅拷贝
const a1 = [1, 2]
const a2 = [...a1]
const [...a2] = a1

// 合并数组
const a1 = [1, 2]
const a2 = [3]
const a3 = [4, 5]

// es5
a1.concat(a2, a3)

// es6
[...a1, ...a2, ...a3]
```

- 将字符串转为真正的数组
```js
[...'hello']
// ['h', 'e', 'l', 'l', 'o']
```

### Array.from()

- 用于将两类对象转为真正的数组：类似数组的对象和可遍历对象（Set、Map）
```js
let arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
}
// es5
var arr1 = [].slice.call(arrayLike) // ['a', 'b', 'c']

// es6
var arr2 = Array.from(arrayLike) // ['a', 'b', 'c']
```

- 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组
```js
Array.from('hello')
let nameSet = new Set(['a', 'b'])
Array.from(nameSet) // ['a', 'b']
```

- 任何有length属性的对象，都可以通过Array.from方法转为数组
```js
Array.from({ length: 3 })
```

- polyfill
```js
const toArray = (() => {
  Array.from ? Array.from : obj => [].slice.call(obj)
})()
```

- 第二个参数：类似数组的map方法
```js
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

### Array.of()

- 将一组值，转换为数组
```js
Array.of(3, 11, 8) // [3, 11, 8]
Array.of(3) // [3]
Array.of(3).length // 1
```

### copyWithin

- 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法，会修改当前数组

### find()、findIndex()

- find用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined

- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

- 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象

### fill

```js
// 填充数组
new Array(3).fill(7)
[7, 7, 7]

// 制定填充的起始位置和结束位置
['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']

// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

let arr = new Array(3).fill({name: "Mike"});
arr[0].name = "Ben";
arr
// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
```

### entries()、keys()、values()

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"

// 如果不使用for...of循环，可以手动调用遍历器的next方法，进行遍历
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

### includes
```js
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

### flat、flatMap
```js
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]

// flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。

[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]

// flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。

// flatMap()只能展开一层数组。

// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

### 数组的空位

- es6明确将空位转为undefined

## 对象的扩展

### 属性的简洁表示法
```js
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}

const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
};
```

### 属性名表达式
```js
// es5
var obj = {
  foo: true,
  abc: 123
}

// es6
let propKey = 'foo'
let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
}

// 定义方法名
let obj = {
  ['h' + 'ello']() {
    return 'hi'
  }
}
obj.hello()

// 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

### 方法的name属性

```js
const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // "sayName"


const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"

(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"

const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

### Object.is

- 行为和`===`基本类似，不同之处：
```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### Object.assign()

> 这是浅拷贝

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

// 如果只有一个参数，Object.assign会直接返回该参数。

const obj = {a: 1};
Object.assign(obj) === obj // true
```

### 属性的可枚举性和遍历

- 可枚举性
```js
let obj = { foo: 123 }
Object.getOwnPropertyDescriptor(obj, 'foo')
// {
//   value: 123,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

### 属性的遍历

- es6一共有5中方法可以遍历对象的属性
  - for...in：遍历对象自身的和继承的可枚举属性（不含Symbol属性）
  - Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名
  - Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名
  - Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有Symbol属性的键名
  - Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是Symbol或字符串，也不管是否可枚举
  - 遵守同样的属性遍历次序规则：
    - 首先遍历所有数值键，按照数值升序排列
    - 其次遍历所有字符串键，按照加入时间升序排列
    - 最后遍历所有Symbol键，按照加入时间升序排列

### Object.getOwnPropertyDescriptors()

- Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象，es7引入了这个方法来返回指定对象所有自身属性（非继承属性）的描述对象

- 引入的目的主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题
```js
const source = {
  set foo(value) {
    console.log(value)
  }
}
const target1 = {}
Object.assign(target1, source)

Object.getOwnPropertyDescriptor(target1, 'foo')
// {
//   value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

- 正确的拷贝：
```js
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
```

### __proto__、Object.setPrototypeOf()、Object.getPrototypeOf()

#### __proto__

- 用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性
```js
// es5
const obj = {
  method: function () {}
}
obj.__proto__ = someOtherObj

// es6
var obj = Object.create(someOtherObj)
obj.method = function () {}
```

- 标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。

#### Object.setPrototypeOf()

- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身
```js
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
```

#### Object.getPrototypeOf()

- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。
```js
Object.getPrototypeOf(obj);
```

### super关键字

- 我们知道，this关键字总是指向函数所在的当前对象，es6又新增了另一个类似的关键字super，指向当前对象的原型对象
```js
const proto = {
  foo: 'hello'
}

const obj = {
  foo: 'world',
  find() {
    return super.foo
  }
}

Object.setPrototypeOf(obj, proto)
obj.find() // 'hello'
```

### Object.keys()、Object.values()、Object。entries()

#### Object.keys()
- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键名
```js
var obj = { foo: 'bar', baz: 42 }
Object.keys(obj)

let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

#### Object.values()

- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键值
```js
const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// ["bar", 42]
```

#### Object.entries

- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键值对数组
```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

- 如果原对象的属性名是一个Symbol值，该属性会被忽略
```js
Object.entries({ [Symbol()]: 123, foo: 'abc' });
// [ [ 'foo', 'abc' ] ]
```

- 基本用途：
```js
// 遍历对象的属性
let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2

// 将对象转为真正的Map结构
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
```

### 扩展运算符

#### 解构赋值
```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

- 不能复制继承自原型对象的属性

#### 属性拷贝
```js
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
```

#### 完整的克隆一个对象

```js
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
}

const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
)

const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

## Symbol

### 概述
```js
let s = Symbol()
typeof s // 'symbol'
```
- 变量s是一个独一无二的值
- Symbol函数前不能使用new命令，否则会报错，因为生成的Symbol是一个原始类型的值，不是对象。由于Symbol值不是对象，所以不能添加属性

### 接受一个字符串为参数
```js
let s1 = Symbol('foo')
let s2 = Symbol('bar')

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // 'Symbol(foo)'
s2.toString() // 'Symbol(bar)'
```

- 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。

```js
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
```

- 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
```

- Symbol值不能和其他类型的值进行运算，会报错
```js
let sym = Symbol('My symbol');

"your symbol is " + sym
// TypeError: can't convert symbol to string
`your symbol is ${sym}`
// TypeError: can't convert symbol to string
```

- Symbol值可以显式转为字符串
```js
let sym = Symbol('My symbol');

String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
```

- Symbol值可以转为布尔值，但不能转为数值
```js
let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
  // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
```

### 作为属性名的Symbol

- 由于每一个Symbol值都是不相等的，意味着Symbol值可以作为标识符，用于对象的属性名，能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
```js
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

- Symbol值作为对象属性名时，不能用点运算符，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号中
```js
const mySymbol = Symbol()
const a = {}

a.mySymbol = 'hello!'
a[mySymbol] // undefined
a['mySymbol'] // 'hello!'

let s = Symbol()
let obj = {
  [s]: function (arg) {},
  [b](arg) {}
}
obj[s](123)
```

- Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的
```js
const log = {}

log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn')
}

console.log(log.levels.DEBUG, 'debug message');
console.log(log.levels.INFO, 'info message');
```

- Symbol值作为属性名时，该属性还是公开属性，不是私有属性

### 遍历

- Symbol作为属性名，不会出现在for..in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。它也不是私有属性，可以通过Object.getOwnPropertySymbols方法，获取指定对象的所有Symbol属性名

- Reflect.ownKeys可以返回所有类型的键名，包括常规键名和Symbol键名

### Symbol.for()、Symbol.keyFor()

- Symbol.for方法可以重新使用同一个Symbol值，它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值
```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')

s1 === s2 // true
```

- Symbol.keyFor方法返回一个已登记的Symbol类型值的key
```js
let s1 = Symbol.for('foo')
Symbol.keyFor(s1) // foo

let s2 = Symbol('foo')
Symbol.keyFor(s2) // undefined
```

### 内置的Symbol值

- Symbol.hasInstance：当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法
```js
class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array
  }
}

[1, 2, 3] instanceof new MyClass() // true
```

- Symbol.isConcatSpreadable：等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开
```js
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

- Symbol.species：实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。

- Symbol.match：指向一个函数，当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值

- Symbol.replace：指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值

- Symbol.search：指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值

- Symbol.split：指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值

- Symbol.iterator：指向该对象的默认遍历器方法
```js
const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]
```

- Symbol.toPrimitive：指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。
  - Number：该场合需要转成数值
  - String：该场合需要转成字符串
  - Default：该场合可以转成数值，也可以转成字符串
```js
let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
```

- Symbol.toStringTag：对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。
```js
// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// "[object Foo]"

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // "[object xxx]"
```

- Symbol.unscopables：指向一个对象，该对象指定了使用with关键字时，哪些属性会被with环境排除

## Set和Map数据结构

### Set

- 类似于数组，但是成员的值都是唯一的，没有重复的值
- 本身是一个构造函数，用来生成Set数据结构
```js
const s = new Set()
[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x))
for(let i of s) {
  console.log(i) // 2 3 5 4
}
```
- 可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数来初始化
```js
const set = new Set([1, 2, 3, 4, 4]);
[...set] // [1, 2, 3, 4]

const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5
```
- 数组去重
```js
const set = new Set([1, 1, 1]) // Set {1}
[...set] // [1]

set.size // 1
```
- 向Set加入值的时候，不会发生类型转换，所以5和'5'是两个不同的值，NaN是同一个值，两个对象总是不相等的
```js
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

set.add({})
set.size // 2

set.add({})
set.size // 3
```

#### 实例的属性和方法

- Set.prototype.constructor: 构造函数，默认就是Set函数
- Set.prototype.size: 返回Set实例的成员总和
- add(value): 添加某个值，返回Set结构本身
- delete(value): 删除某个值，返回一个布尔值，表示删除是否成功
- has(value): 返回一个布尔值，表示该值是否为Set的成员
- clear(): 清除所有成员，没有返回值
```js
s.add(1).add(2).add(2);
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2)
s.has(2) // false
```
- 去除数组重复成员的另一种方法
```js
function dedupe(array) {
  return Array.from(new Set(array))
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]
```

#### 遍历操作

- Set结构的实例有四个遍历方法：
  - keys(): 返回键名的遍历器
  - values(): 返回键值的遍历器
  - entries(): 返回键值对的遍历器
  - forEach(): 使用回调函数遍历每个成员

#### 遍历应用

```js
let set = new Set(['red', 'green', 'blue']);
let arr = [...set]; // ['red', 'green', 'blue']

let arr = [3, 3, 3, 3];
let unique = [...new Set(arr)]; // [3]

let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));// {2, 4, 6}

let set = new Set([1, 2, 3, 4, 5])
set = new Set([...set].filter(x => (x % 2) == 0)); // {2, 4}
```

- 并集、交集、差集
```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x))); // Set {2, 3}

// 差集
let difference = new Set([...a].filter(x => !b.has(x))); // Set {1}
```

- 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。
```js
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6
```

### weakSet

- 含义：结构和Set类似，也是不重复值的集合，和Set的区别
  - 成员只能是对象，不能是其他类型的值（如Number、Symbol等）
  - 成员对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收改对象所占用的内存，不考虑该对象还存在于WeakSet之中
  - 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
  - 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。
  - 这些特点同样适用于WeakMap结构

### Map

- js的对象，本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键
- 为了解决这个问题，ES6提供了Map数据结构，类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键
- Object结构提供了“字符串-值”的对应，Map结构提供了“值-值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适
```js
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content');
m.get(o); // 'content'

m.has(o); // true
m.delete(o); // true
m.has(o); // false
```
- Map也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组
```js
const map = new Map([
  ['name', 'mallow'],
  ['title', 'test']
])
map.size // 2
map.has('name') // true
map.get('name') // mallow
map.has('title') // true
map.get('title') // test
```
- 事实上，不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素数组的数据结构都可以当作map构造函数的参数。也就是说，Set和Map都可以用来生成新的Map
```js
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```
- 如果对同一个键多次赋值，后面的值将覆盖前面的值
```js
const map = new Map();

map.set(1, 'aaa').set(1, 'bbb');

map.get(1) // 'bbb'
```
- 读取未知的键
```js
new Map().get('fsdlfjasdjf') // undefined
```
- 只用对同一个对象的引用，Map结构才将其视为同一个键，内存地址不一样不会视为同一个键
```js
const map = new Map();
map.set(['a'], 555);
map.get(['a']); // undefined

const map = new Map();
const k1 = ['a'];
const k2 = ['a'];
map.set(k1, 111).set(k2, 222);

map.get(k1); // 111
map.get(k2); // 222
```
- Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
- 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。
```js
let map = new Map();

map.set(-0, 123);
map.get(+0); // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined); // 3

map.set(NaN, 123);
map.get(NaN) // 123
```

### WeakMap
- 使用方法上和WeakSet类似
- 用途：
  - DOM节点作为键名，一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄露风险
  - 部署私有属性，如果删除实例，他们也就随之消失，不会造成内存泄露

## Proxy
- 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程
- 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写
```js
const obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`)
    return Reflect.get(target, key, receiver)
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`)
    return Reflect.set(target, key, value, receiver)
  }
})
obj.test // getting test!
obj.test = 1 // setting test!
```

- ES6原生提供Proxy构造函数，用来生成Proxy实例
```js
// target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为
var proxy = new Proxy(target, handler);
const proxy = new Proxy({}, {
  get: function() {
    return 35
  }
})
console.log(proxy.time) // 35

// 如果handler没有设置任何拦截，那就等同于直接通向原对象

const target = {};
const handler = {};
const proxy = new Proxy(target, handler);
proxy.a = 'b';
target.a // 'b'
```

- 技巧
```js
// 将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用
const object = { proxy: new Proxy(target, handler) };

// Proxy实例也可以作为其他对象的原型对象
const proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
```
- 设置拦截多个操作
```js
const handler = {
  get: function(target, name) {
    if (name === 'prototype') {
      return Object.prototype;
    }
    return 'Hello, ' + name;
  },
  apply: function(target, thisBinding, args) {
    return args[0];
  },
  construct: function(target, args) {
    return {value: arge[1]};
  }
};

const fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // {value: 2}
fproxy.prototype === Object.prototype // true
fproxy.foo === 'Hello, foo' // true
```
- Proxy支持的拦截操作一览：
  - get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']
  - set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo=v或proxy['foo']=v，返回一个布尔值
  - has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值
  - deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值
  - ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性
  - getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象
  - defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值
  - preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值
  - getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象
  - isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值
  - setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外的操作可以拦截
  - apply(target, object, args)：拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)
  - construct(target, args)：拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)