---
title: 对比
order: 5
type: framework
---

## Vue vs React

### 共同点
- 使用`Virtual DOM`
- 响应式和组件化的视图组件
- 将注意力集中保持在核心库，将其他功能如路由和全局状态管理交给相关的库

### 生态系统
- 目前React的生态系统比Vue庞大，Vue正在赶超

### 运行时性能&优化
#### 共同点
- 运行时非常快，性能好

#### Vue
- 组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了shouldComponentUpdate，并且没有上述子树问题限制
  - 这个特点使得开发者不再需要考虑此类优化，从而能够更好的专注于应用本身

#### React
- 当某个组件的状态发生变化是，它会以该组件为根，重新渲染整个组件子树
  - 如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用`PureComponent`，或是手动实现shouldComponentUpdate方法。同时你可能会需要使用不可变的数据结构来使得组件更容易被优化
  - 使用PureComponent和shouldComponentUpdate时，需要保证该组件的整个子树的渲染输出都是由该组件的props所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致，这使得React中的组件优化伴随着相当的心智负担

### HTML&CSS

#### Vue
- 拥抱经典的Web技术，并在其上进行扩展
- 很多主流的css-in-js库也都支持vue（styled-components-vue和vue-emotion），设置样式的默认方法是单文件组件里类似style的标签
  - 通过vue-loader，可以使用任意的预处理器、后处理器，甚至深度集成在css modules中

- 也提供了渲染函数，支持jsx，但是默认推荐模版。任何合乎规范的html都是合法的vue模版，优势：
  - 模版比起jsx读写起来更自然
  - 基于HTML的模版使得将已有应用逐步迁移到Vue更容易
  - 更容易上手
  - 可以使用其他模版预处理器，比如：Pug、less、jade等
  - 具有v-on等修饰符，可以比React更为简洁的实现功能
  - 偏视图表现的使用模版，偏逻辑的使用jsx或渲染函数
  - style使用scoped属性绑定样式

#### React
- 一切都是js，不仅仅是HTML可以用JSX来表达，现在的潮流也越来越多地将CSS纳入到js中来处理
- 所有的组件的渲染功能都依靠jsx，jsx是使用XML语法来编写js的一种语法糖，优势：
  - 使用完整的编程语言js功能来构建你的视图页面。比如：临时变量、流程控制、直接引用当前js作用域中的值等
  - 开发工具对jsx的支持相比于现有可用的其他Vue模版还是比较先进的：linting、类型检查、编辑器的自动完成

- CSS-in-JS：引入了一个新的面向组件的样式范例，和普通的css撰写过程是有区别的，虽然在构建时将css提取到一个单独的样式表是支持的，但bundle里通常还是需要一个运行时程序来让这些样式生效。当你能够利用js灵活处理样式的同时，也需要权衡bundle的尺寸和运行时的开销

### 规模

#### 共同点
- 都提供了强大的路由来应对大型应用，提供了状态管理工具（Redux、Vuex）。

#### Vue
- 路由库和状态管理库都是由官方维护支持且和核心库同步更新
- Vue-cli
  - 支持配置
  - 提供了各种用途的模版
  - 能使用用户自建的模版构建项目，对企业环境下预先建立协议是特别有用的

#### React
- 路由库和状态管理库交给社区维护，创建了一个更分散的生态系统，相对的，生态系统更加繁荣
- create-react-app
  - 不允许在项目生成时进行任何配置
  - 只提供一个构建单页面应用的单一模版
  - 不能使用用户自建的模版构建项目
  - 故意设计这些限制，如果你的项目需求非常简单，就不需要自定义生成过程，你能把它作为一个依赖来更新

### 向下扩展
#### Vue
- 容易上手，可使用外链脚本

#### React
- 需要知道jsx和es2015，这个也不难

### 原生渲染
#### Vue
- Weex

#### React
- React Native

## Vue vs AngularJS
### 共同点
- 一些语法相似（v-if vs ng-if）

### 复杂性
Vue比Angular简单的多

### 灵活性和模块化
Vue更加灵活开放，不用在任何时候都必须遵循AngularJS制定的规则，Vue能适用于各种项目，决定权在你手中

### 数据绑定
AngularJS使用双向绑定，Vue在不同组件间强制使用单向数据流，使得应用中的数据流更加清晰易懂

### 指令和组件
在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。在 AngularJS 中，每件事都由指令来做，而组件只是一种特殊的指令。

### 运行时性能

#### Vue
- 有更好的性能，非常容易优化，不使用脏检查
- 基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系

#### AngularJS
- 当watcher越来越多时会变得越来越慢，因为作用域每一次变化，所有watcher都要重新计算，如果一些watcher触发另一个更新，脏检查循环可能要运行多次。用户常常需要使用深奥的计数来解决脏检查循环的问题，没有简单的方法来优化有大量watcher的作用域
- Angular和Vue用相似的设计解决了一些AngularJS中存在的问题

## Vue vs Angular
### 相同点
- 运行速度很快

### Angular
- ts
- 体积大、大量api、对新手不友好
- 针对大型的复杂应用

### Vue
- 体积小、灵活

## Knockout
- 支持IE6

## 原理

### vue
**结合生命周期理解**
**深入响应式原理：**数据模型的改变会更新视图，而数据模型仅仅只是普通的js对象，这使得状态管理变得很简单直接。
- 如何追踪变化：当你把一个普通的js对象传给vue实例的data选项，Vue将遍历此对象所有的属性，并使用`Object.defineProperty`(es5中无法shim的特性，故Vue不支持ie8以及更低版本浏览器)把这些属性全部转为`getter/setter`
- 这些属性对用户来说是不可见的，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化
- 每个组件实例都有相应的`watcher`实例对象，它会在组件渲染过程中把属性记录为依赖，之后当依赖项的`setter`被调用时，会通知`watcher`重新计算，从而使它关联的组件得以更新
![data](../../images/data.png)

**检测变化的注意事项：**受现代`js`的限制（以及废弃`Object.observe`），`Vue`不能检测到对象属性的添加或删除。由于 `Vue` 会在初始化实例时对属性执行 `getter/setter` 转化过程，所以属性必须在 `data` 对象上存在才能让 `Vue` 转换它，这样才能让它是响应的。
解决方式：
1. Vue.set(object, key, value)
1. this.$set(object, key, value)
1. 创建一个新的对象，例：this.someObject = Object.assign({}, this.someObject, {a: 1, b: 2})
1. 针对数组，不能检测以下变动的数组：
    - 当你利用索引直接设置一个项时：可使用`Vue.set(vm.array, index, newValue)` or `vm.items.splice(index, 1, newValue)` or `this.$set`
    - 当你修改数组的长度时：`splice`

**异步更新队列：**`Vue` 异步执行 `DOM` 更新。只要观察到数据变化，`Vue` 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 `watcher` 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 `DOM` 操作上非常重要。然后，在下一个的事件循环“`tick`”中，`Vue` 刷新队列并执行实际 (已去重的) 工作。`Vue` 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MessageChannel`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。例：
```html
<div id="example">{{message}}</div>
<script>
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'new message' // 更改数据
vm.$el.textContent === 'new message' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
})
</script>
```

### react
**什么是虚拟dom:**虚拟DOM（VDOM）是一种编程概念，是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与“真实”的DOM保持同步。这个过程被称为和解。
这种编程方法使用了React的声明式API：你需要告诉React你想让视图处于什么状态，React则负责确保DOM与该状态相匹配。因此你在构建你的应用时不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。
由于“虚拟DOM”更像一种模式而不是特定的技术，有时候我们也会用它表示其他的意思。在React的世界中，由于 “虚拟DOM” 和 React元素 都是用于表示视图的对象，因此常常被关联在一起。然而React也使用被称为“fibers”的对象来存放组件树的附加信息。在React中，它们也被认为是“虚拟DOM”实现的一部分。

- 页面空白但是没有报错，可能是因为函数名和关键字冲突
- 组件导入不了，提示空的对象，原因是命名的时候首字母没有大写！！！（指class的名字）
- export default Abc 导入单个class组件不能带{}

### angular
**使用脏检查**
**页面庞大时需要调用apply()方法手动触发页面脏检查**

#### 脏检查
> [知乎](https://www.zhihu.com/question/43470158)

DI / 双向数据绑定中：
- 用户 -> 内存 ：
  - 浏览器提供有User Event触发事件的API，如click，change...等等等；、
  
- 内存 -> 用户：
  - 浏览器并没有提供数据监测的API，故任何内存数据变动（定时、异步请求、事件触发...导致的数据变动）都无法被Listen，自然也就没办法再处理callback了；
  - 但我们可以基于这些大部分能够产生数据变动的事件进行封装（如：click、mouse-enter、Timeout...），在每次事件发生后，执行完事件后，检查一遍数据的变化，如果数据和上次的值有变化，则执行这个值（注册时）对应的callback（框架中），这个callback可能是view层的一个数据展现，也可能是一段处理function；
  - 在检查数据变化的时候，由于你并不知道这个事件是对哪些数据进行了更改，以及这个事件有可能造成事件之外的其他任何地方的数据更改，所以必须进行一次大检查，将所有“注册”过的值全部检查一遍，一次检查称为一个周期，每次最少检查两遍，因为第二遍用来确认，前一遍的变动中是否有数据的变动，导致了其他数据的变动，如果第二次有变动的话，会再执行一遍，直到最后两次完全一致，则停止检查（其实就是个（递归（遍历））的过程），考虑到内存的消耗和死循环的风险，脏检查每个周期最多递归执行10遍，所以在程序结构设计中，尽量避免数据与数据之间的紧耦合；
  - 所以我们看到的
    - ng-click，ng-change，ng-blur...就是对各类用户事件的封装
    - $timeout，$http，$window，$location...就是对各种JS/API事件的封装
    - ng-model，以及控制器中的数据，就是对值的“注册”
    - $scope 本质是一个总的事件逻辑的封装容器，同时抽象为数据载体，
  - 实质上数据都存在于浏览器堆内存中
    - $scope.apply() & $scope.digest() 即Angular中的“数据大检查”的function
    - 所以如果我们使用了非Angular封装的事件改编数据时，要手动执行一次大检查
    - 由于Angular这种脏检查的方法效率不高，如果一个页面绑定的view超过2000个，就可能存在比较明显的性能问题，官方称之为“脏检查”

### 对比
[参考资料](https://cn.vuejs.org/v2/guide/comparison.html)