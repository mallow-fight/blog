---
title: es6
order: 8
type: js
---

## let和const

### let

- let所声明的变量，只在let命令所在的代码块内有效

- for循环
  - 如果使用var声明i，由于全局只有一个变量i，会导致每次循环引用的变量i都是同一个，这个仅限于循环内部有函数引用或者有延时操作，正常函数内部打印i还是ok的，例子：
  ```js
  var a = []
  for(var i = 0; i < 10; i++) {
    a[i] = function () {
      console.log(i)
    }
    console.log(i) // 0 ~ 9
  }
  a[9]() // 10
  i // 10：因为要做 i < 10 的判断，所以i肯定是10
  ```
  - 如果使用let，声明的变量仅在块级作用域内有效，每一次循环都是一个新的变量。js引擎内部会记住上一轮循环的值，初始化本轮变量i时，就是在上一轮循环的基础上进行计算
  - 特殊之处：设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域
  ```js
  for(let i = 0; i < 3; i++) {
    // console.log(i) i is not defined
    let i = 'mallow'
    console.log(i) // mallow
  }
  ```

- 不存在变量提升：使用var会发生变量提升的现象，值为undefined，let改变了语法行为，它所声明的对象一定要在声明后使用

- 暂时性死区：只要块级作用域内存在let或const命令，它所声明的变量就绑定了这个区域，不再受外部的影响，同上面的for循环特殊之处
```js
var tmp = 123
if (true) {
  tmp = 'abc' // ReferenceError: tmp is not defined
  let tmp
}
```

- 不允许重复声明
```js
function func(arg) {
  let arg // SyntaxError: Identifier 'arg' has already been declared
}
function func(arg) {
  {
    let arg
  }
}
```

### 块级作用域

- es5只有全局作用域和函数作用域，没有块级作用域，带来的不合理场景：
  - 内层变量可能会覆盖外层变量：变量提升导致的
  ```js
  var tmp = new Date()
  function f() {
    console.log(tmp)
    if(false) {
      var tmp = 'hello world'
    }
  }
  f()
  ```
  - 用来计数的循环变量泄漏为全局变量
  ```js
  var s = 'hello'
  for(var i = 0; i < s.length; i++) {
    console.log(s[i])
  }
  console.log(i)
  ```

- es6的块级作用域
  - let实际上为js新增了块级作用域
  - 允许块级作用域的任意嵌套
  - 内层作用域可以定义外层作用域的同名变量
  - 块级作用域的出现，实际上使得广泛应用的立即执行函数表达式（IIFE）不再必要了
  ```js
  // IIFE 写法
  (function () {
    var tmp = 'xxx'
  }())

  // 块级作用域写法
  {
    let tmp = 'xxx'
  }
  ```

### 块级作用域和函数声明

- 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

### const

- 声明一个只读的常量，一旦声明，值就不能改变

- 作用域和let相同：只在声明所在的块级作用域内有效

- 声明的常量也不提升，同样存在暂时性死区

- 不可重复声明

#### 本质

- const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量

- 对于复合类型的数据（数组、对象），变量指向的是内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了
  - 如果真想将对象冻结，应该使用Object.freeze方法：
  ```js
  const foo = Object.freeze({})
  // 常规模式时，下面一行不起作用
  // 严格模式时，该行会报错
  foo.prop = 123
  ```
  - 除了将对象本身冻结，对象的属性也应该被冻结，如：
  ```js
  function freeze(obj) {
    Object.freeze(obj)
    Object.keys(obj).forEach(key => {
      if(typeof obj[key] === 'object') {
        freeze(obj[key])
      }
    })
  }
  ```

### 声明对象的六种方法

- es5声明变量的方法：var、function
- es6：let、const、import、class

### 顶层对象的属性

- 在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性和全局变量是等价的

- ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定：let、const、class命令声明的全局对象，不属于顶层对象的属性。全局变量将逐步和顶层对象的属性脱钩

### global对象

- 不同环境的global对象不一样，垫片库 system.global 模拟了这个提案，可以在所有环境拿到global

## 变量的解构赋值

### 数组

```js
// before
let a = 1
let b = 2
let c = 3

// now
let [a, b, c] = [1, 2, 3]
```

#### 模式匹配

```js
let [a, [b, c]] = [1, [2, 3]]
let [ , , e] = [1, 2, 3]
let [f, , g] = [1, , 3]
let [h, ...j] = [1, 2, 3, 4] // j: [2, 3, 4]
let [x, y, ...z] = [1] // x: 1; y: undefined; z: []
```

#### 不完全解构

```js
let [x, y] = [1, 2, 3]
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4]
a // 1
b // 2
d // 4
```

#### 不可遍历结构

```js
// 报错
let [foo] = 1
let [foo] = false
let [foo] = NaN
let [foo] = undefined
let [foo] = null
let [foo] = {}
```

#### Set结构

```js
let [x, y, z] = new Set(['a', 'b', 'c'])
x // 'a'

// 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs() {
  let a = 0
  let b = 1
  while (true) {
    yield a; // 这个地方必须要有分号
    [a, b] = [b, a + b];
  }
}
let [one, two, three, four, five, six] = fibs()
six // 5
```

#### 默认值

```js
let [foo = true] = []
foo // true
let [x, y = 'b'] = ['a'] // x: a; y: b
let [x, y = 'b'] = ['a', undefined] // x: a; y: b
// 只有undefined，默认值才生效
let [x = 1] = [null] // x: null

// 默认值是表达式
function f() {
  console.log('aaa')
}
let [x = f()] = [1] // 因为x能取到值，所以表达式是惰性求值的，即只有在用到的时候才会求值
```

#### 引用其他变量

> 变量必须提前声明

```js
let [x = 1, y = x] = [] // x: 1; y: 1
let [x = 1, y = x] = [2] // x: 2; y: 2
let [x = 1, y = x] = [1, 2] // x: 1; y: 2
let [x = y, y = 1] = [] // ReferenceError: y is not defined
```

### 对象

- 数组元素是按次序排列的，变量取值由它的位置决定的；而对象的属性没有次序，变量必须和属性同名，才能取到正确的值
```js
let {bar, foo, baz} = { foo: 'aaa', bar: 'bbb' }
foo // aaa
bar // bbb
baz // undefined
```

#### 变量名和属性名不一致

```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // 'aaa'

let obj = { first: 'hello', last: 'world' }
let { first: f, last: l } = obj
f // 'hello'
l // 'world'
```

- 实际上，对象的解构赋值是下面形式的简写
```js
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }
```

- 也就是说，是先找到同名属性，然后再赋值给对应的变量。
```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' }
baz // aaa
foo // error: foo is not defined
```

#### 嵌套结构的对象

```js
let obj = {
  p: [
    'hello',
    { y: 'World' }
  ]
}
let { p: [x, { y }] } = obj
x // 'Hello'
y // 'World'

// 将p作为变量赋值
let { p, p: [x, { y }] } = obj
x // Hello
y // World
p // [Hello, {y: World}]

// 解构到对象或数组
let obj = {}
let arr = []
// 这个地方必要要有()，避免js将其解释为代码块
({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true })
obj // {prop: 123}
arr // [true]
```

#### 默认值

- 同样：默认值生效的条件是，对象的属性值严格等于undefined

```js
let {x = 3} = {}
let {x: y = 4} = {x: 5} // y: 5
```

#### 对数组进行对象属性的解构

```js
let arr = [1, 2, 3]
let {0: first, [arr.length - 1] : last} = arr
first // 1
last // 3
```

### 字符串

```js
const [a, b, c, d, e] = 'hello'
a // h
b // e
c // l
d // l
e // o

let {length: len} = 'hello'
len // 5
```

### 数值和布尔值

```js
let {toString: s} = 123
s === Number.prototype.toString // true
let {toString: s} = true
s === Boolean.prototype.toString // true

let { prop: x } = undefined // TypeError
let { prop: y } = null // TypeError
```

### 函数参数

```js
function add([x, y]) {
  return x + y
}
add([1, 2]) // 3

function move({x = 0, y = 0} = {}) {
  return [x, y]
}
move({x: 3, y: 8}) // [3, 8]
move({x: 3}) // [3, 0]
move({}) // [0, 0]
move() // [0, 0]
```

### 圆括号

- 尽量不要使用圆括号

- 可以使用圆括号的情况只有一种：赋值语句的非模式部分
```js
[(b)] = [3]
({ p: (d) } = {})
[(parseInt.prop)] = [3]
```

### 用途

- 交换变量的值
```js
let x = 1
let y = 2
[x, y] = [y, x]
```

- 从函数返回多个值
```js
function example() {
  return [1, 2, 3]
}
let [a, b, c] = example()

function exmaple() {
  return {
    foo: 1,
    bar: 2
  }
}
let { foo, bar } = exmaple()
```

- 函数参数的定义
```js
// 参数是一组有次序的值
function f([x, y, z]) {}
f([1, 2, 3])

// 参数是一组无次序的值
function f({x, y, z}) {}
f({z: 3, y: 2, x: 1})
```

- 提取JSON数据
```js
let json = {
  id: 42,
  status: 'ok',
  data: [111, 222]
}
let { id, status, data: numbers } = json
console.log(id, status, numbers)
```

- 函数参数的默认值
```js
function foo(a = 1, b = 2, c = false) {}
```

- 遍历Map解构：任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map解构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便
```js
const map = new Map()
map.set('first', 'hello')
map.set('second', 'world')
for(let [key, value] of map) {
  console.log(key + ' is ' + value)
}
for(let [key] of map) {}
for(let [, value] of map) {}
```

### 输入模块的制定方法
```js
const { a, b } = require('ModuleName')
```

## 字符串的扩展

### Unicode表示法

- js允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点

- 这种表示法只限于码点在\u0000~\uFFFF之间的字符，超出这个范围的字符，必须用两个双字节的形式表示

```js
"\u0061" // "a"

"\uD842\uDFB7" // 𠮷

"\u20BB7" // " 7" js会理解成\u20BB+7
```

- es6的改进：只要将码点放入大括号，就能正确解读该字符

```js
"\u{20BB7}" // "𠮷"
"\u{41}\u{42}\u{43}"
// "ABC"

let hello = 123;
hell\u{6F} // 123

'\u{1F680}' === '\uD83D\uDE80'
// true
```

- 6中方法表示一个字符

```js
'\z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

### codePointAt

```js
var s = "𠮷";

s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```

```js
let s = '𠮷a';

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97

// 十六进制的值
let s = '𠮷a';

s.codePointAt(0).toString(16) // "20bb7"
s.codePointAt(2).toString(16) // "61"

let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61

function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}

is32Bit("𠮷") // true
is32Bit("a") // false
```

### String.fromCodePoint

```js
String.fromCharCode(0x20BB7)
// "ஷ"

String.fromCodePoint(0x20BB7)
// "𠮷"
String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'
// true
```

### 遍历器接口

```js
for (let codePoint of 'foo') {
  console.log(codePoint)
}
// "f"
// "o"
// "o"

let text = String.fromCodePoint(0x20BB7);

for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "

for (let i of text) {
  console.log(i);
}
// "𠮷"
```

### normalize

```js
'\u01D1'==='\u004F\u030C' //false

'\u01D1'.length // 1
'\u004F\u030C'.length // 2

// 用来将字符的不同表示方法统一为同样的形式，称为Unicode正规化
'\u01D1'.normalize() === '\u004F\u030C'.normalize()
// true
```

- normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。
  - NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
  - NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
  - NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
  - NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
  ```js
  '\u004F\u030C'.normalize('NFC').length // 1
  '\u004F\u030C'.normalize('NFD').length // 2
  ```

### includes()、startsWith()、endsWith()

- includes(): 返回布尔值，表示是否找到了参数字符串
- startsWith(): 返回布尔值，表示参数字符串是否在原字符串的头部
- endsWith(): 返回布尔值，表示参数字符串是否在原字符串的尾部

```js
let s = 'Hello world!'
s.startsWidth('Hello') // true
s.endsWith('!') // true
s.includes('o') // true

// 支持第二个参数，表示开始搜索的位置
let s = 'Hello world!';
s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
```

### repeat()

- 返回一个新字符串，表示将原字符串重复n次
```js
'x'.repeat(3) // 'xxx'
'hello'.repeat(2) // 'hellohello'
'na'.repeat(0) // ''
'na'.repeat(2.9) // 'nana'
'na'.repeat(Infinity) // RangeError
'na'.repeat(-1) // RangeError
'na'.repeat(-0.9) // ''
'na'.repeat(NaN) // ''
'na'.repeat('na') // ''
'na'.repeat('3') // 'nanana'
```

### padStart()、padEnd()

- es2017引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全

```js
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'

'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'

'abc'.padStart(10, '0123456789') // '0123456abc'

'x'.padStart(4) // '    x'
'x'.padEnd(4) // 'x    '

// 用途：为数值补全指定位数
'1'.padStart(10, '0') // '0000000001'
'12'.padStart(10, '0') // '0000000012'
'123456'.padStart(10, '0') // '0000123456'

// 用途：提示字符串格式
'12'.padStart(10, 'YYYY-MM-DD') // 'YYYY-MM-12'
'09-12'.padStart(10, 'YYYY-MM-DD') // 'YYYY-09-12'
```

### matchAll()

- 返回一个正则表达式在当前字符串的所有匹配

### 模版字符串

```js
// 所有的空格和缩进都会被保留在输出之中
`
<ul>
  <li>first</li>
  <li>second</li>
</ul>
`
// 如果不想用<ul>标签前面的换行，可以使用trim方法消除它
```

- 需要将变量名写在`${}`之中

- 还能嵌套：
```js
`${`${var2}`var1}`
```

### 模版编译

- [vue和react都有使用](http://es6.ruanyifeng.com/#docs/string#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91)

### 标签模版

```js
alert`123`
// 等同于
alert(123)

let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);

function tag(stringArr, value1, value2){
  // ...
}

// 等同于

function tag(stringArr, ...values){
  // ...
}
```

## RegExp构造函数

- [参考地址](http://es6.ruanyifeng.com/#docs/regex)

## 数值的扩展

- [参考地址](http://es6.ruanyifeng.com/#docs/number)

### Number.isFinite()，Number.isNaN()

- 和传统的全局方法isFinite()和isNaN的区别：传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false，Number.isNaN()对NaN返回true，非NaN一律返回false

```js
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
Number.isNaN(1) // false
```

### Number.isInteger()

- 用来判断一个数值是否为整数
```js
Number.isInteger(25) // true
Number.isInteger(25.1) // false
Number.isInteger(25.0) // false
Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
Number.isInteger(3.0000000000000002) // true
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```

### Math对象的扩展

#### Math.trunc()
- 去除一个数的小数部分，返回整数部分
```js
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
```

- 对于非数值，内部会使用Number方法将其先转为数值
```js
Math.trunc('123.456') // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
```

- 对于空值和无法截取整数的值，返回NaN
```js
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
```

#### Math.sign()

- 用来判断一个数到底是正数、负数还是零。对于非数值，会先将其转换为数值
  - 参数为正数，返回+1
  - 参数为负数，返回-1
  - 参数为0，返回0
  - 参数为-0，返回-0
  - 其他值，返回NaN

```js
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN

Math.sign('')  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign('9')  // +1
Math.sign('foo')  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
```

#### 指数运算符

```js
2 ** 2 // 4
2 ** 3 // 8

2 ** 3 ** 2 // 相当于 2 ** (3 ** 2) = 512
```

## 函数的扩展

### 参数的默认值

```js
// before es6
function log(x, y) {
  y = y || 'World';
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello World

// after es6
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Point();
p // { x: 0, y: 0 }
```

- 阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档
- 有利于将来的代码优化，即使未来版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行

- 参数变量是默认声明的，所以不能用let或const再次声明。

```js
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

- 使用参数默认值时，函数不能有同名参数。

```js
// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
```

- 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
```

- 和解构赋值默认值结合使用

```js
function foo({x, y = 5}) {
  console.log(x, y)
}
foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError

function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5

function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}

fetch('http://example.com', {})
// "GET"

fetch('http://example.com')
// 报错

function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
// "GET"
```

- 练习
```js
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
```

- 参数默认值的位置
```js
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]

function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
```

### length属性

- 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真

### 作用域

```js
// example-1
var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2

// example-2
let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1

// example-3
function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // ReferenceError: x is not defined

// example-4
var x = 1;

function foo(x = x) {
  // ...
}

foo() // ReferenceError: x is not defined

// example-5
let foo = 'outer';

function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar(); // outer

// example-6
function bar(func = () => foo) {
  let foo = 'inner';
  console.log(func());
}

bar() // ReferenceError: foo is not defined

// example-7
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}

foo() // 3
x // 1

// example-8
var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}

foo() // 2
x // 1

// 指定某一个参数不得省略，如果省略就抛出一个错误
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter

// 将参数默认值设为undefined，表明这个参数可以省略的
function foo(optional = undefined) { ··· }
```

### rest参数

- 用于获取函数的多余参数，这样就不需要使用arguments对象了，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中
```js
function add(...values) {
  let sum = 0
  for (var val of values) {
    sum += val
  }
  return sum
}
add(2, 5, 3) // 10
```

- example:
```js
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();

function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```

- rest参数之后不能再有其他参数
```js
// 报错
function f(a, ...b, c) {
  // ...
}
```

- 函数的length属性，不包括rest参数
```js
(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
```

### 严格模式

- 从es5开始，函数内部可以设定为严格模式

- es6做了一点修改，规定只要函数参数使用了默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错

### name属性

- 函数的name属性，返回该函数的函数名

```js
function foo() {}
foo.name // 'foo'

var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"

const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"

(new Function).name // "anonymous"

function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
```

### 箭头函数

- 基本用法

```js
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};

var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};

var sum = (num1, num2) => { return num1 + num2; }

// 报错
let getTempItem = id => { id: id, name: "Temp" };

// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });

let foo = () => { a: 1 };
foo() // undefined

// 箭头函数只有一行语句，且不需要返回值
let fn = () => void doesNotReturn();

const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}

const isEven = n => n % 2 == 0;
const square = n => n * n;

// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) => a - b);

const numbers = (...nums) => nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) => [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
```

#### 注意点

- 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，不能使用call、apply、bind这些方法去改变this的指向

- 不可以当作构造函数，也就是说不可以使用new命令，否则会抛出一个错误

- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。也不存在super、new.target

- 不可以使用yield命令，因此箭头函数不能用作Generator函数

### 双冒号运算符

```js
foo::bar
// 等同于
bar.bind(foo)

foo::bar(...arguments)
// 等同于
bar.apply(foo, arguments)
```

### 尾调用优化

> es6的尾递归优化只在严格模式下开启，正常模式是无效的，因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈：func.arguments、func.caller

- 是函数式编程的一个重要概念，指某个函数的最后一步是调用另一个函数
```js
function f(x) {
  return g(x)
}
```

- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

- 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”
```js
function addOne(a) {
  var one = 1
  function inner(b) {
    return b + one
  }
  return inner(a)
}
```

- 非尾递归的 Fibonacci 数列实现如下。
```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
```

- 尾递归优化过的 Fibonacci 数列实现如下。
```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

- es6第一次明确规定，所有ECMAScript的实现，都必须部署尾递归，这样就不会发生栈溢出，相对节省内存。

- 函数柯里化
```js
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120

// 采用es6的函数默认值
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

#### 尾递归优化的实现

- 蹦床函数
```js
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f()
  }
  return f
}
```

- 真正的实现
```js
function tco(f) {
  var value
  var active = false
  var accumulated = []
  return function accumulator() {
    accumulated.push(arguments)
    if(!active) {
      active = false
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift())
      }
      active = false
      return value
    }
  }
}

var sum = tco(function(x, y) {
  if(y > 0) {
    return sum(x + 1, y -1)
  } else {
    return x
  }
})

sum(1, 100000)
```

- 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

## 数组的扩展

### 扩展运算符

```js
...[1, 2, 3]
// 1 2 3

// 函数调用
function push(array, ...items) {
  array.push(...items)
}

function add(x, y) {
  return x + y
}

const numbers = [4, 38]
add(...numbers) // 42
```

- 该方法可以替代函数的apply方法

- 应用
```js
// 复制数组，是一种浅拷贝
const a1 = [1, 2]
const a2 = [...a1]
const [...a2] = a1

// 合并数组
const a1 = [1, 2]
const a2 = [3]
const a3 = [4, 5]

// es5
a1.concat(a2, a3)

// es6
[...a1, ...a2, ...a3]
```

- 将字符串转为真正的数组
```js
[...'hello']
// ['h', 'e', 'l', 'l', 'o']
```

### Array.from()

- 用于将两类对象转为真正的数组：类似数组的对象和可遍历对象（Set、Map）
```js
let arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
}
// es5
var arr1 = [].slice.call(arrayLike) // ['a', 'b', 'c']

// es6
var arr2 = Array.from(arrayLike) // ['a', 'b', 'c']
```

- 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组
```js
Array.from('hello')
let nameSet = new Set(['a', 'b'])
Array.from(nameSet) // ['a', 'b']
```

- 任何有length属性的对象，都可以通过Array.from方法转为数组
```js
Array.from({ length: 3 })
```

- polyfill
```js
const toArray = (() => {
  Array.from ? Array.from : obj => [].slice.call(obj)
})()
```

- 第二个参数：类似数组的map方法
```js
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

### Array.of()

- 将一组值，转换为数组
```js
Array.of(3, 11, 8) // [3, 11, 8]
Array.of(3) // [3]
Array.of(3).length // 1
```

### copyWithin

- 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法，会修改当前数组

### find()、findIndex()

- find用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined

- 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

- 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象

### fill

```js
// 填充数组
new Array(3).fill(7)
[7, 7, 7]

// 制定填充的起始位置和结束位置
['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']

// 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

let arr = new Array(3).fill({name: "Mike"});
arr[0].name = "Ben";
arr
// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
```

### entries()、keys()、values()

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"

// 如果不使用for...of循环，可以手动调用遍历器的next方法，进行遍历
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

### includes
```js
[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
```

### flat、flatMap
```js
[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]

// flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。

[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]

// flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。

// flatMap()只能展开一层数组。

// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

### 数组的空位

- es6明确将空位转为undefined

## 对象的扩展

### 属性的简洁表示法
```js
function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}

const o = {
  method() {
    return "Hello!";
  }
};

// 等同于

const o = {
  method: function() {
    return "Hello!";
  }
};
```

### 属性名表达式
```js
// es5
var obj = {
  foo: true,
  abc: 123
}

// es6
let propKey = 'foo'
let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
}

// 定义方法名
let obj = {
  ['h' + 'ello']() {
    return 'hi'
  }
}
obj.hello()

// 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```

### 方法的name属性

```js
const person = {
  sayName() {
    console.log('hello!');
  },
};

person.sayName.name   // "sayName"


const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name // "get foo"
descriptor.set.name // "set foo"

(new Function()).name // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"

const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
```

### Object.is

- 行为和`===`基本类似，不同之处：
```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

### Object.assign()

> 这是浅拷贝

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

// 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}

// 如果只有一个参数，Object.assign会直接返回该参数。

const obj = {a: 1};
Object.assign(obj) === obj // true
```

### 属性的可枚举性和遍历

- 可枚举性
```js
let obj = { foo: 123 }
Object.getOwnPropertyDescriptor(obj, 'foo')
// {
//   value: 123,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

### 属性的遍历

- es6一共有5中方法可以遍历对象的属性
  - for...in：遍历对象自身的和继承的可枚举属性（不含Symbol属性）
  - Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名
  - Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名
  - Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有Symbol属性的键名
  - Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是Symbol或字符串，也不管是否可枚举
  - 遵守同样的属性遍历次序规则：
    - 首先遍历所有数值键，按照数值升序排列
    - 其次遍历所有字符串键，按照加入时间升序排列
    - 最后遍历所有Symbol键，按照加入时间升序排列

### Object.getOwnPropertyDescriptors()

- Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象，es7引入了这个方法来返回指定对象所有自身属性（非继承属性）的描述对象

- 引入的目的主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题
```js
const source = {
  set foo(value) {
    console.log(value)
  }
}
const target1 = {}
Object.assign(target1, source)

Object.getOwnPropertyDescriptor(target1, 'foo')
// {
//   value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

- 正确的拷贝：
```js
const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, 'foo')
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
```

### __proto__、Object.setPrototypeOf()、Object.getPrototypeOf()

#### __proto__

- 用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性
```js
// es5
const obj = {
  method: function () {}
}
obj.__proto__ = someOtherObj

// es6
var obj = Object.create(someOtherObj)
obj.method = function () {}
```

- 标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。

#### Object.setPrototypeOf()

- Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身
```js
let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
```

#### Object.getPrototypeOf()

- 该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。
```js
Object.getPrototypeOf(obj);
```

### super关键字

- 我们知道，this关键字总是指向函数所在的当前对象，es6又新增了另一个类似的关键字super，指向当前对象的原型对象
```js
const proto = {
  foo: 'hello'
}

const obj = {
  foo: 'world',
  find() {
    return super.foo
  }
}

Object.setPrototypeOf(obj, proto)
obj.find() // 'hello'
```

### Object.keys()、Object.values()、Object。entries()

#### Object.keys()
- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键名
```js
var obj = { foo: 'bar', baz: 42 }
Object.keys(obj)

let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

#### Object.values()

- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键值
```js
const obj = { foo: 'bar', baz: 42 };
Object.values(obj)
// ["bar", 42]
```

#### Object.entries

- 返回一个数组，成员是参数对象自身的不含继承的所有可遍历属性的键值对数组
```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj)
// [ ["foo", "bar"], ["baz", 42] ]
```

- 如果原对象的属性名是一个Symbol值，该属性会被忽略
```js
Object.entries({ [Symbol()]: 123, foo: 'abc' });
// [ [ 'foo', 'abc' ] ]
```

- 基本用途：
```js
// 遍历对象的属性
let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// "one": 1
// "two": 2

// 将对象转为真正的Map结构
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: "bar", baz: 42 }
```

### 扩展运算符

#### 解构赋值
```js
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

- 不能复制继承自原型对象的属性

#### 属性拷贝
```js
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
```

#### 完整的克隆一个对象

```js
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
}

const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
)

const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
```

## Symbol

### 概述
```js
let s = Symbol()
typeof s // 'symbol'
```
- 变量s是一个独一无二的值
- Symbol函数前不能使用new命令，否则会报错，因为生成的Symbol是一个原始类型的值，不是对象。由于Symbol值不是对象，所以不能添加属性

### 接受一个字符串为参数
```js
let s1 = Symbol('foo')
let s2 = Symbol('bar')

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // 'Symbol(foo)'
s2.toString() // 'Symbol(bar)'
```

- 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。

```js
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
```

- 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
```

- Symbol值不能和其他类型的值进行运算，会报错
```js
let sym = Symbol('My symbol');

"your symbol is " + sym
// TypeError: can't convert symbol to string
`your symbol is ${sym}`
// TypeError: can't convert symbol to string
```

- Symbol值可以显式转为字符串
```js
let sym = Symbol('My symbol');

String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
```

- Symbol值可以转为布尔值，但不能转为数值
```js
let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
  // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
```

### 作为属性名的Symbol

- 由于每一个Symbol值都是不相等的，意味着Symbol值可以作为标识符，用于对象的属性名，能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
```js
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

- Symbol值作为对象属性名时，不能用点运算符，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号中
```js
const mySymbol = Symbol()
const a = {}

a.mySymbol = 'hello!'
a[mySymbol] // undefined
a['mySymbol'] // 'hello!'

let s = Symbol()
let obj = {
  [s]: function (arg) {},
  [b](arg) {}
}
obj[s](123)
```

- Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的
```js
const log = {}

log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn')
}

console.log(log.levels.DEBUG, 'debug message');
console.log(log.levels.INFO, 'info message');
```

- Symbol值作为属性名时，该属性还是公开属性，不是私有属性

### 遍历

- Symbol作为属性名，不会出现在for..in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。它也不是私有属性，可以通过Object.getOwnPropertySymbols方法，获取指定对象的所有Symbol属性名

- Reflect.ownKeys可以返回所有类型的键名，包括常规键名和Symbol键名

### Symbol.for()、Symbol.keyFor()

- Symbol.for方法可以重新使用同一个Symbol值，它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值
```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')

s1 === s2 // true
```

- Symbol.keyFor方法返回一个已登记的Symbol类型值的key
```js
let s1 = Symbol.for('foo')
Symbol.keyFor(s1) // foo

let s2 = Symbol('foo')
Symbol.keyFor(s2) // undefined
```

### 内置的Symbol值

- Symbol.hasInstance：当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法
```js
class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array
  }
}

[1, 2, 3] instanceof new MyClass() // true
```

- Symbol.isConcatSpreadable：等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开
```js
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

- Symbol.species：实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。

- Symbol.match：指向一个函数，当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值

- Symbol.replace：指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值

- Symbol.search：指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值

- Symbol.split：指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值

- Symbol.iterator：指向该对象的默认遍历器方法
```js
const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};
[...myIterable] // [1, 2, 3]
```

- Symbol.toPrimitive：指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。
  - Number：该场合需要转成数值
  - String：该场合需要转成字符串
  - Default：该场合可以转成数值，也可以转成字符串
```js
let obj = {
  [Symbol.toPrimitive](hint) {
    switch (hint) {
      case 'number':
        return 123;
      case 'string':
        return 'str';
      case 'default':
        return 'default';
      default:
        throw new Error();
     }
   }
};

2 * obj // 246
3 + obj // '3default'
obj == 'default' // true
String(obj) // 'str'
```

- Symbol.toStringTag：对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。
```js
// 例一
({[Symbol.toStringTag]: 'Foo'}.toString())
// "[object Foo]"

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return 'xxx';
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // "[object xxx]"
```

- Symbol.unscopables：指向一个对象，该对象指定了使用with关键字时，哪些属性会被with环境排除

## Set和Map数据结构

### Set

- 类似于数组，但是成员的值都是唯一的，没有重复的值
- 本身是一个构造函数，用来生成Set数据结构
```js
const s = new Set()
[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x))
for(let i of s) {
  console.log(i) // 2 3 5 4
}
```
- 可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数来初始化
```js
const set = new Set([1, 2, 3, 4, 4]);
[...set] // [1, 2, 3, 4]

const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5
```
- 数组去重
```js
const set = new Set([1, 1, 1]) // Set {1}
[...set] // [1]

set.size // 1
```
- 向Set加入值的时候，不会发生类型转换，所以5和'5'是两个不同的值，NaN是同一个值，两个对象总是不相等的
```js
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

set.add({})
set.size // 2

set.add({})
set.size // 3
```

#### 实例的属性和方法

- Set.prototype.constructor: 构造函数，默认就是Set函数
- Set.prototype.size: 返回Set实例的成员总和
- add(value): 添加某个值，返回Set结构本身
- delete(value): 删除某个值，返回一个布尔值，表示删除是否成功
- has(value): 返回一个布尔值，表示该值是否为Set的成员
- clear(): 清除所有成员，没有返回值
```js
s.add(1).add(2).add(2);
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2)
s.has(2) // false
```
- 去除数组重复成员的另一种方法
```js
function dedupe(array) {
  return Array.from(new Set(array))
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]
```

#### 遍历操作

- Set结构的实例有四个遍历方法：
  - keys(): 返回键名的遍历器
  - values(): 返回键值的遍历器
  - entries(): 返回键值对的遍历器
  - forEach(): 使用回调函数遍历每个成员

#### 遍历应用

```js
let set = new Set(['red', 'green', 'blue']);
let arr = [...set]; // ['red', 'green', 'blue']

let arr = [3, 3, 3, 3];
let unique = [...new Set(arr)]; // [3]

let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));// {2, 4, 6}

let set = new Set([1, 2, 3, 4, 5])
set = new Set([...set].filter(x => (x % 2) == 0)); // {2, 4}
```

- 并集、交集、差集
```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x))); // Set {2, 3}

// 差集
let difference = new Set([...a].filter(x => !b.has(x))); // Set {1}
```

- 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。
```js
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6
```

### weakSet

- 含义：结构和Set类似，也是不重复值的集合，和Set的区别
  - 成员只能是对象，不能是其他类型的值（如Number、Symbol等）
  - 成员对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收改对象所占用的内存，不考虑该对象还存在于WeakSet之中
  - 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
  - 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。
  - 这些特点同样适用于WeakMap结构

### Map

- js的对象，本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键
- 为了解决这个问题，ES6提供了Map数据结构，类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键
- Object结构提供了“字符串-值”的对应，Map结构提供了“值-值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适
```js
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content');
m.get(o); // 'content'

m.has(o); // true
m.delete(o); // true
m.has(o); // false
```
- Map也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组
```js
const map = new Map([
  ['name', 'mallow'],
  ['title', 'test']
])
map.size // 2
map.has('name') // true
map.get('name') // mallow
map.has('title') // true
map.get('title') // test
```
- 事实上，不仅仅是数组，任何具有Iterator接口、且每个成员都是一个双元素数组的数据结构都可以当作map构造函数的参数。也就是说，Set和Map都可以用来生成新的Map
```js
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```
- 如果对同一个键多次赋值，后面的值将覆盖前面的值
```js
const map = new Map();

map.set(1, 'aaa').set(1, 'bbb');

map.get(1) // 'bbb'
```
- 读取未知的键
```js
new Map().get('fsdlfjasdjf') // undefined
```
- 只用对同一个对象的引用，Map结构才将其视为同一个键，内存地址不一样不会视为同一个键
```js
const map = new Map();
map.set(['a'], 555);
map.get(['a']); // undefined

const map = new Map();
const k1 = ['a'];
const k2 = ['a'];
map.set(k1, 111).set(k2, 222);

map.get(k1); // 111
map.get(k2); // 222
```
- Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
- 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。
```js
let map = new Map();

map.set(-0, 123);
map.get(+0); // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined); // 3

map.set(NaN, 123);
map.get(NaN) // 123
```

### WeakMap
- 使用方法上和WeakSet类似
- 用途：
  - DOM节点作为键名，一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄露风险
  - 部署私有属性，如果删除实例，他们也就随之消失，不会造成内存泄露

## Proxy
- 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程
- 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写
```js
const obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`)
    return Reflect.get(target, key, receiver)
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`)
    return Reflect.set(target, key, value, receiver)
  }
})
obj.test // getting test!
obj.test = 1 // setting test!
```

- ES6原生提供Proxy构造函数，用来生成Proxy实例
```js
// target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为
var proxy = new Proxy(target, handler);
const proxy = new Proxy({}, {
  get: function() {
    return 35
  }
})
console.log(proxy.time) // 35

// 如果handler没有设置任何拦截，那就等同于直接通向原对象

const target = {};
const handler = {};
const proxy = new Proxy(target, handler);
proxy.a = 'b';
target.a // 'b'
```

- 技巧
```js
// 将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用
const object = { proxy: new Proxy(target, handler) };

// Proxy实例也可以作为其他对象的原型对象
const proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
```
- 设置拦截多个操作
```js
const handler = {
  get: function(target, name) {
    if (name === 'prototype') {
      return Object.prototype;
    }
    return 'Hello, ' + name;
  },
  apply: function(target, thisBinding, args) {
    return args[0];
  },
  construct: function(target, args) {
    return {value: arge[1]};
  }
};

const fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // {value: 2}
fproxy.prototype === Object.prototype // true
fproxy.foo === 'Hello, foo' // true
```
- Proxy支持的拦截操作一览：
  - get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']
  - set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo=v或proxy['foo']=v，返回一个布尔值
  - has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值
  - deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值
  - ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性
  - getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象
  - defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs)，返回一个布尔值
  - preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值
  - getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象
  - isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值
  - setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外的操作可以拦截
  - apply(target, object, args)：拦截Proxy实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)
  - construct(target, args)：拦截Proxy实例作为构造函数调用的操作，比如new proxy(...args)
- Proxy实例方法
  - get()：用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和操作行为所针对的对象，其中最后一个参数可选
  ```js
  const person = {
    name: '张三'
  };
  const proxy = new Proxy(person, {
    get: function(target, property) {
      if (property in target) {
        return target[property];
      } else {
        throw new ReferenceError(`Property ${property} does not exist.`);
      }
    }
  });
  proxy,name // '张三'
  proxy.age // 抛出一个错误
  ```
  - get方法可以继承：
  ```js
  let proto = new Proxy({}, {
    get(target, propertyKey, receiver) {
      console.log('GET ' + propertyKey);
      return target[propertyKey];
    }
  });
  let obj = Object.create(proto);
  obj.foo // 'GET foo'
  ```
  - 使用get拦截，实现数组负数的索引
  ```js
  function createArray(...elements) {
    const handler = {
      get(target, propKey, receiver) {
        let index = Number(propKey);
        if (index < 0) {
          propKey = String(target.length + index);
        }
        return Reflect.get(target, propKey, receiver);
      }
    };
    let target = [];
    target.push(...elements);
    return new Proxy(target, handler);
  }
  let arr = createArray('a', 'b', 'c');
  const a = arr[-1] // c
  ```
  - 利用Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作
  ```js
  // 这个只适合在最外层window环境下运行
  var pipe = (function () {
    return function (value) {
      var funcStack = [];
      var oproxy = new Proxy({} , {
        get : function (pipeObject, fnName) {
          if (fnName === 'get') {
            return funcStack.reduce(function (val, fn) {
              return fn(val);
            },value);
          }
          funcStack.push(window[fnName]);
          return oproxy;
        }
      });
      return oproxy;
    }
  }());
  var double = n => n * 2;
  var pow    = n => n * n;
  var reverseInt = n => n.toString().split("").reverse().join("") | 0;
  pipe(3).double.pow.reverseInt.get; // 63
  ```
  - proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象
  ```js
  const proxy = new Proxy({}, {
    get: function (target, property, receiver) {
      return receiver;
    }
  });
  const d = Object.create(proxy);
  d.a === d; // true
  ```
  - 如果一个属性不可配置且不可写，则Proxy不能修改该属性，否则通过Proxy对象访问该属性会报错
  ```js
  const target = Object.defineProperties({}, {
    foo: {
      value: 123,
      writable: false,
      configurable: false
    }
  })
  const handler = {
    get(target, propKey) {
      return 'abc'
    }
  }
  const proxy = new Proxy(target, handler);
  proxy.foo
  ```
  - set(): 用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值、Proxy实例本身，其中最后一个参数可选
  ```js
  let validator = {
    set: function(obj, prop, value) {
      if(prop === 'age') {
        if(!Number.isInteger(value)) {
          throw new TypeError('The age is not an integer');
        }
        if(value > 200) {
          throw new RangeError('The age seems invalid');
        }
      }
      obj[prop] = value;
    }
  }
  let person = new Proxy({}, validator);
  person.age = 100;
  person.age // 100
  person.age = 'young' // 报错
  person.age = 300 // 报错
  ```
  - 属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用
  ```js
  const handler = {
    get (target, key) {
      invariant(key, 'get')
      return target[key]
    },
    set (target, key, value) {
      invariant(key, 'set')
      target[key] = value
      return true
    }
  }
  function invariant(key, action) {
    if (key[0] === '_') {
      throw new Error(`Invalid attempt to ${action} private "${key}" property`)
    }
  }
  const target = {}
  const proxy = new Proxy(target, handler)
  proxy._prop
  proxy._prop = 'c'
  ```

#### apply()
- 拦截函数的调用、call和apply操作
- 接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组
```js
const handler = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments)
  }
}

const target = function () {
  return 'I am the target'
}
const handler = {
  apply: function () {
    return 'I am the proxy'
  }
}
const p = new Proxy(target, handler)
p() // I am the proxy
```

## Reflect

### 概述
- Reflect对象和Proxy对象一样，也是ES6为了操作对象而提供的新API，目的：
  - 将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上，从Reflect对象上可以拿到与眼内不到方法
  - 修改某些Object方法的返回结果，如Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false
  ```js
  // old
  try {
    Object.defineProperty(target, property, attributes)
  } catch (e) {

  }

  // new
  if (Reflect.defineProperty(target, property, attributes)) {

  } else {

  }
  ```
  - 让Object操作都变成函数行为
  ```js
  // old
  'assign' in Object // true
  
  // new
  Reflect.has(Object, 'assign') // true
  ```
  - Reflect对象的方法和Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法，让Proxy对象可以方便的调用对应的Reflect方法，完成默认行为，总可以在Reflect上获取默认行为
  ```js
  Proxy(target, {
    set: function(target, name, value, receiver) {
      const success = Reflect.set(target, name, value, receiver)
      if (success) {
        log(`property ${name} on ${target} set to ${value}`);
      }
      return success;
    }
  })
  ```

### Reflect.get(target, name, receiver)

- 查找并返回target对象的name属性，如果没有该属性，则返回undefined
```js
const myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar
  }
}

Reflect.get(myObject, 'foo') // 1
Reflect.get(myObject, 'bar') // 2
Reflect.get(myObject, 'baz') // 3

// 第一个参数必须是对象
Reflect.get(1, 'foo') // error
Reflect.get(false, 'foo') // error
```

### Reflect.set(target, name, value, receiver)
- 如果name属性设置了赋值函数，则赋值函数的this绑定receiver
```js
const myObject = {
  foo: 4,
  set bar(value) {
    return this.foo = value
  }
}
const myReceiverObject = {
  foo: 0
}
Reflect.set(myObject, 'bar', 1, myReceiverObject)
myObject.foo // 4
myReceiverObject.foo // 1
```

### 简单的观察者模式

```js
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}
```

## Promise对象

- 比回调函数和事件：更合理和强大
- 就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
- 特点：
  - 对象的状态不受外界影响，代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejeced（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为resolved（已定型）。

### 基本用法

```js
const promise = new Promise(function(resolve, reject) {
  if(success) {
    resolve(value)
  } else {
    reject(error)
  }
})
```

- resolve函数作用：将Promise对象的状态从未完成变为成功（pending->resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- reject函数作用：将Promise对象状态从未完成变为失败（pending->rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去
- Promise新建后就会立即执行
```js
const promise = new Promise(function(resolve, reject) {
  console.log('promise')
  resolve(console.log('resolve1'))
})
promise.then(function() {
  console.log('resolve2')
})
console.log('hi')
// promise
// resolve1
// hi
// resolve2
```
- 异步加载图片
```js
function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image()
    image.onload = function() {
      resolve(image)
    }
    image.onerror = function() {
      reject(new Error(`Could not load image at ${url}`))
    }
    image.src = url
  })
}
```
- 用Promise对象实现的Ajax操作的例子
```js
const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject) {
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response)
      } else {
        reject(new Error(this.statusText))
      }
    }
    const client = new XMLHttpRequest()
    client.open('GET', url)
    client.onreadystatechange = handler
    client.responseType = 'json'
    client.setRequestHeader('Accept', 'application/json')
    client.send()
  })
  return promise
}
getJSON('/posts.json').then(function(json) {
  console.log('Contents: ' + json)
}, function(error) {
  console.error('出错了', error)
})
```
- 执行顺序：如果出现reject，那么之后的then里面的resolve和reject都不会执行，但是同步操作还是会执行，catch只会捕获第一个报错，后面的报错不会捕获，可以在当前promise加上catch来捕获错误
```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('fail')), 3000)
}).catch(e => console.log(e))
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve(p1), 1000)
})
const p3 = new Promise((resolve, reject) => {
  resolve('i am p3')
})
p2.then(res2 => console.log(res2))
  .then(res3 => p3)
  .catch(error => console.log(error))
```
- 一般来说，调用resolve或reject之后，Promise的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面，所以，最好在他们前面加上return语句，这样就不会有意外
```js
new Promise((resolve, reject) => {
  return resolve(1)
})
```
- Promise.prototype.then()：then方法定义在Promise.prototype上

- Promise.prototype.catch()：是.then(null, rejection)的别名，用于指定发生错误时的回调函数

- 跟传统的try/catch代码块不同的是，如果没有使用catch方法制定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应
```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    resolve(x + 2)
  })
}
```
- 这个脚本放在服务器执行，退出码就是0（表示执行成功），Node有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数
```js
process.on('unhandledRejection', function (err, p) {
  throw err
})
```

- Promise.all()：将多个Promise实例，包装成一个新的Promise实例
```js
const p = Promise.all([p1, p2, p3])
```
- p的状态由p1、p2、p3决定，分成两种情况：
  - 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值按照数组的顺序组成一个数组，传递给p的回调函数
  - 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数，如果实例自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法

- Promise.race()：返回率先改变的Promise实例的返回值

- 立即resolve的Promise对象，是在本轮时间循环的结束时，而不是在下一轮事件循环的开始时
```js
setTimeout(function () {
  console.log('three')
}, 0)
Promise.resolve().then(function () {
  console.log('two')
})
console.log('one')

// one
// two
// three
```

- Promise.reject()：返回一个新的Promise实例，该实例的状态为rejected
```js
const p = Promise.reject('error')

// same as
const p = new Promise((resolve, reject) => reject('error'))

p.then(null, function (s) {
  console.log(s)
})
```

- Generator函数和Promise的结合：
```js
function getFoo () {
  return new Promise(function (resolve, reject) {
    resolve('foo')
  })
}
const g = function* () {
  try {
    const foo = yield getFoo()
    console.log(foo)
  } catch(e) {
    console.log(e)
  }
}
function run(generator) {
  const it = generator()
  function go(result) {
    if(result.done) return result.value
    return result.value.then(function (value) {
      return go(it.next(value))
    }, function (error) {
      return go(it.throw(error))
    })
  }
  go(it.next())
}
run(g)
```
- Promise.try()：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用Promise来处理它。这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误

## Iterator和for...of循环

### Iterator的概念

- js原有的表示集合的数据结构，主要是数组和对象，es6又添加了Map和Set

- Iterator就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作

- Iterator作用：
  - 为各种数据结构，提供一个统一的、简便的访问接口
  - 使得数据结构的成员能够按某种次序排列
  - es6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费

- Iterator遍历过程：
  - 创建一个指针对象，指向当前数据结构的起始位置。遍历器对象本质上，就是一个指针对象
  - 第一次调用指针对象的next方法，指针就指向数据结构的第一个成员
  - 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员
  - 不断调用指针对象的next方法，直到它指向数据结构的结束位置

- 每一次调用next方法，都会返回数据结构的当前成员的信息。返回一个包含value和done两个属性的对象。value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束，模拟next方法：
```js
const it = makeIterator(['a', 'b'])
it.next() // { value: 'a', done: false }
it.next() // { value: 'b', done: false }
it.next() // { value: undefined, done: true }
function makeIterator(array) {
  let nextIndex = 0
  return {
    next: function() {
      return nextIndex < array.length ? 
      {value: array[nextIndex++], done: false} :
      {value: undefined, done: true}
    }
  }
}
```
- 对于遍历器对象来说，done: false和value: undefined 属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式
```js
function makeIterator(array) {
  let nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length ?
        {value: array[nextIndex++]} :
        {done: true};
    }
  };
}
```

### 默认Iterator接口

- 为所有的数据结构，提供了统一的访问机制，即for...of循环。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口
- 一种数据结构只要部署了Iterator接口，我们就称这种数据结构是可遍历的
- 默认的Iterator接口部署在数据结构的Symbol.iterator属性，这个属性本身是一个函数，就是当前数据结构默认的遍历器生成函数
```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      next: function() {
        return {
          value: 1,
          done: true
        }
      }
    }
  }
}
```
- 一个对象如果具备可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法
```js
class RangeIterator {
  constructor(start, stop) {
    this.value = start
    this.stop = stop
  }
  [Symbol.iterator]() { return this; }
  next() {
    let value = this.value
    if(value < this.stop) {
      this.value++
      return {done: false, value}
    }
    return {done: true, value: undefined}
  }
}
function range(start, stop) {
  return new RangeIterator(start, stop)
}
for(let value of range(0, 3)) {
  console.log(value) // 0, 1, 2
}
```

### 调用Iterator接口的场合

- for...of循环

- 解构赋值
```js
let set = new Set().add('a').add('b').add('c');
let [x, y] = set; // x='a'; y='b'
let [first, ...rest] = set; // first='a'; rest=['b', 'c']
```

- 扩展运算符
```js
let str = 'hello';
[...str] // ['h', 'e', 'l', 'l', 'o']

let arr = ['b', 'c'];
['a', ...arr, 'd'] // ['a', 'b', 'c', 'd']
```

- `yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口
```js
let generator = function* () {
  yield 1;
  yield* [2, 3, 4];
  yield 5;
}
const iterator = generator();

iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
```

- 其他：
  - for...of
  - Array.from()
  - Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
  - Promise.all()
  - Promise.race()

### 字符串的Iterator接口
```js
let someString = 'hi'
typeof someString[Symbol.iterator] // function
let iterator = someString[Symbol.iterator]();

iterator.next()  // { value: "h", done: false }
iterator.next()  // { value: "i", done: false }
iterator.next()  // { value: undefined, done: true }
```

### 对象
- 对于普通的对象，for...of结构不能直接使用，会报错，必须部署了Iterator接口后才能使用，这种情况下，for...in循环依然可以用来遍历键名

- 解决方法
```js
for (let key of Object.keys(someObject)) {
  console.log(key)
}

// or
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]]
  }
}
for (let [key, value] of entries(obj)) {
  console.log(key, '->', value)
}
```

- for...of不同于forEach方法，可以与break、continue、return配合使用

## Generator函数的语法

### 基本概念

- 特征：
  - function关键字和函数名之间有一个星号
  - 函数体内部使用yield（意思：产出）表达式，定义不同的内部状态
  ```js
  function* helloWorldGenerator() {
    yield 'hello'
    yield 'world'
    return 'ending'
  }
  const hw = helloWorldGenerator
  ```

- yield表达式
  - 由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数，yield表达式就是暂停标志
  - next方法的运行逻辑：
    - 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回对象的value属性值
    - 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式
    - 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值
    - 如果该函数没有return语句，则返回的对象的value属性值为undefined
  - yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为js提供了手动的惰性求值
  ```js
  function* gen() {
    yield 123 + 456;
  }
  ```
  - yield表达式如果用在另一个表达式之中，必须放在圆括号里面
  ```js
  function* demo() {
    console.log('Hello' + yield) // SyntaxError
    console.log('Hello' + yield 123) // SyntaxError

    console.log('Hello' + (yield)) // ok
    console.log('Hello' + (yield 123)) // ok
  }
  ```
  - yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号
  ```js
  function* demo() {
    foo(yield 'a', yield 'b') // ok
    let input = yield // ok
  }
  ```
  - 与Iterator接口的关系
  ```js
  const myIterable = {};
  myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
  };
  [...myIterable] // [1, 2, 3]
  ```

### next方法的参数

- `yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值
```js
function* f() {
  for(var i = 0; true; i++) {
    var reset = yield i;
    if(reset) { i= -1; }
  }
}
const g = f();
g.next();
g.next();
g.next(true);
```
- 这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为
```js
function* foo(x) {
  let y = 2 * (yield (x + 1));
  let z = yield (y / 3);
  return (x + y + z);
}

let a = foo(5);
a.next()
a.next()
a.next()

let b = foo(5)
b.next()
b.next(12)
b.next(13)
```
- 向Generator函数内部输入值的例子
```js
function* dataConsumer() {
  console.log('start')
  console.log(`${yield}`)
  console.log(`${yield}`)
  return 'result'
}
const it = dataConsumer()
it.next() // start
it.next('a') // a
it.next('b') // b
```
- 如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层
```js
function wrapper(generatorFunction) {
  return function (...args) {
    let generatorObject = generatorFunction(...args);
    generatorObject.next();
    return generatorObject;
  };
}
const wrapped = wrapper(function* () {
  console.log(`First input: ${yield}`);
  return 'DONE';
})
wrapped().next('hello!')
```

### for...of循环
- for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法
```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}
for(let v of foo()) {
  console.log(v) // 1 2 3 4 5
}
```

- 利用Generator函数和for...of循环，实现斐波那契数列
```js
function* fibonacci() {
  let [prev, curr] = [0, 1]
  for(;;) {
    yield curr
    [prev, curr] = [curr, prev + curr]
  }
}
for(let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n)
}
```
- 利用for...of循环，可以写出遍历任意对象的方法。原生的js对象没有遍历接口
```js
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj)
  for(let propKey of propKeys) {
    yield [propKey, obj[propKey]]
  }
}
let jane = { first: 'Jane', last: 'Doe' }
for (let [key, value] of ObjectEntries(jane)) {
  console.log(`${key}: ${value}`)
}
// first: Jane
// last: Doe
```
- 其他遍历器接口
```js
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}
// 扩展运算符
[...numbers()] // [1, 2]

// Array.from
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers()

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
```

### Generator.prototype.throw()

```js
const g = function* () {
  try {
    yield
  } catch (e) {
    console.log('inside', e)
  }
}
const it = g()
it.next()
try {
  it.throw('a') // 被generator捕获
  it.throw('b') // 被外面的catch捕获
  it.throw(new Error('ds')) // 被吞掉
} catch(e) {
  console.log('outside', e)
}
it.throw(new Error('c')) // 会报错
```
- 如果Generator函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行
- throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法
```js
function* gen() {
  try {
    yield 1
  } catch (e) {
    console.log('inside')
  }
}
const g = gen()
g.throw(1)
```
- throw方法被捕获之后，会附带执行下一条yield表达式，也就是说，会附带执行一次next方法
```js
const gen = function* () {
  try {
    yield console.log('a')
  } catch (e) {
    console.log('inside')
  }
  yield console.log('b')
  yield console.log('c')
}
const it = gen()
it.next() // a
it.throw() // b
it.next() // c
```
- 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即js引擎认为这个Generator已经运行结束了
```js
function* g() {
  yield 1;
  console.log('throwing an exception');
  throw new Error('generator broke!');
  yield 2;
  yield 3;
}

function log(generator) {
  var v;
  console.log('starting generator');
  try {
    v = generator.next();
    console.log('第一次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  try {
    v = generator.next();
    console.log('第二次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  try {
    v = generator.next();
    console.log('第三次运行next方法', v);
  } catch (err) {
    console.log('捕捉错误', v);
  }
  console.log('caller done');
}

log(g());
// starting generator
// 第一次运行next方法 { value: 1, done: false }
// throwing an exception
// 捕捉错误 { value: 1, done: false }
// 第三次运行next方法 { value: undefined, done: true }
// caller done
```

### Generator.prototype.return()

- 可以返回给定的值，并且终结遍历Generator函数
```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
const it = gen();
it.next();
it.return('foo');
it.next();
```

### yield* 表达式
- 如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的
- 用这个表达式来在一个Generator函数里面执行另一个Generator函数

### 上下文
```js
function* gen() {
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
}
function F() {
  return gen.call(gen.prototype);
}
const f = new F();
f.next(); // Object {value: 2, done: false}
f.next(); // Object {value: 3, done: false}
f.next(); // Object {value: undefined, done: true}
f.a // 1
f.b // 2
f.c // 3
```

### Generator和状态机
- 更简洁、更安全（状态不会被非法篡改）、更符合函数式编程的思想、在写法上更优雅。之所以可以不用外部变量保存状态，是因为本身包含了一个状态信息，即目前是否处于暂停态
```js
const clock = function* () {
  while(true) {
    console.log('Tick')
    yield
    console.log('Tock')
    yield
  }
}
const it = clock()
it.next()
it.next()
it.next()
for(let i = 0; i < 10; i++) {
  it.next()
}
```

### Generatro和协程
- 协程是一种程序运行的方式，既可以用单线程实现，也可以用多线程实现。

## Generator函数的异步应用

### 传统方法

- 回调函数
- 事件监听
- 发布/订阅
- Promise对象

### 概念

- 异步：一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段
  - 例子：有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步
- 同步：连续的执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着
- 回调函数：把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数
  - 例子：
  ```js
  fs.readFile('/etc/passwd', 'utf-8', function (err, data) {
    if (err) throw err;
    console.log(data);
  })
  ```
- Promise：为了解决回调函数地狱问题，允许将回调函数的嵌套，改成链式调用
- Generator：
  - 协程：多个线程互相协作，完成异步任务
    - 运行流程：
      - 第一步：协程A开始执行
      - 第二步：协程A执行到一半，进入暂停，执行权转移到协程B
      - 第三步：一段时间后协程B交还执行权
      - 第四步：协程A恢复执行
    - 例子：
    ```js
    function* asyncJob() {
      const f = yield readFile(fileA);
    }
    ```
    - 优点：代码的写法非常像同步操作，如果去除yield命令，简直一模一样
  - 实现：最大特点是可以交出函数的执行权（暂停执行）
    - 整个Generator函数就是一个封装的异步任务，或者说异步任务的容器。异步操作需要暂停的地方，都用yield语句注明：
    ```js
    function* gen(x) {
      const y = yield x + 2;
      return y
    }
    const g = gen(1);
    g.next() // { value: 3, done: false }
    g.next() // { value: undefined, done: true }
    ```
    - 调用Generator函数，会返回一个内部指针（遍历器）g，这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针
  - 数据交换和错误处理
    - Generator函数可以暂停执行和恢复执行，是它能封装异步任务的根部原因
  - 异步任务的封装
  ```js
  const fetch = require('node-fetch');
  function* gen(){
    const url = 'http://api.github.com/users/github';
    const result = yield fetch(url);
    console.log(result.bio);
  }
  ```
  - 执行：(流程管理不方便))
  ```js
  const g = gen();
  const result = g.next();
  result.value.then(function(data){
    return data.json();
  }).then(function(data){
    g.next(data);
  });
  ```

### Thunk函数

- 传名调用（参数用到时才计算）

### co函数
```js
const fs = require('fs');

const readFile = function (fileName) {
  return new Promise(function (resolve, reject) {
    fs.readFile(fileName, function(error, data) {
      if(error) return reject(error);
      resolve(data);
    })
  })
}

const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
}

const g = gen();
g.next().value.then(function(data) {
  g.next(data).value.then(function(data){
    g.next(data);
  })
})
```

## async函数

- 是Generator函数的语法糖

- async函数对Generator函数的改进，体现在以下四点
  - 内置执行器：Generator函数的执行必须靠执行器，而async函数自带执行器
  - 更好的语义：比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
  - 更广的适用性：async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，这时等同于同步操作）
  - 返回值是Promise：async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了

### 基本用法

- async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体后面的语句
```js
async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}

getStockPriceByName('goog').then(function (result) {
  console.log(result);
})
```

### 语法

- 返回Promise对象：async函数返回一个Promise对象，async函数内部return语句返回的值，会成为then方法回调函数的参数

```js
async function f() {
  return 'hello world';
}
f().then(v => console.log(v));
```

- Promise对象的状态变化：async函数返回的Promise对象，必须等到内部所有await命令后面的Promise对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数

- await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到
```js
async function f() {
  await Promise.reject('出错了');
}
f()
.then(v => console.log(v))
.catch(e => console.log(e)) // 出错了
```

- 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行
```js
async function f() {
  await Promise.reject('出错了');
  await Promise.resolve('hello world'); // 不会执行
}
```

- 可以使用try...catch来捕获await操作是否失败，这样不管这个异步操作是否成功。第二个await都会执行
```js
async function f() {
  try {
    await Promise.reject('出错了');
  } catch(e) {
    console.log(e)
  }
  return await Promise.resolve('hello world');
}
f().then(v => console.log(v)); // hello world
```

### 错误处理

- 如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject
```js
async function f() {
  await new Promise(function (resolve, reject) {
    throw new Error('出错了');
  })
}

f()
.then(v => console.log(v))
.catch(e => console.log(e)) // Error: 出错了
```

### async函数的实现原理
- 将Generator函数和自动执行器，包装在一个函数里
```js
async function fn(args) {

}

// the same as
 
function fn(args) {
  return spawn(function* () {

  });
}
```

- spawn函数的实现：
```js
function spawn(genF) {
  return new Promise(function(resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch (e) {
        return reject(e);
      }
      if(next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function () { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); })
      });
    }
    step(function() { return gen.next(undefined); });
  })
}
```

## Class的基本语法

### 传统方法

- 构造函数：
```js
function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
}
const p = new Point(1, 2);
```

- class语法糖改写：
```js
// 定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```

- 类的数据类型就是函数，类本身就指向构造函数
```js
class Point {
  getWidth() {
    return 123;
  }
}

typeof Point // function
Point === Point.prototype.constructor // true

const b = new Point();
b.getWidth();
```

- 类的内部所有定义的方法，都是不可枚举的
```js
class Point {
  constructor(x, y) {

  }
  toString() {

  }
}
Object.keys(Point.prototype); // []
Object.getOwnPropertyNames(Point.prototype);// ['constructor', 'toString']
```

### constructor方法

- 类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加
```js
class Point {

}
// 等同于
class Point {
  constructor() {}
}
```

- constructor 方法返回实例对象（即this），完全可以指定返回另外一个对象
```js
class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo; // false
```

- 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行

### Class表达式

- 类也可以使用表达式的形式定义，类的名字是MyClass，Me只在Class内部代码可用，指代当前类
```js
const MyClass = class Me {
  getClassName() {
    return Me.name;
  }
};
let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined.
```

- 如果类的内部没用到的话，可以省略Me
```js
const MyClass = class {};
```

- 立即执行的Class
```js
let person = new class {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(this.name);
  }
}('张三');
person.sayName(); // '张三'
```

- 不存在变量提升
```js
new Foo(); // ReferenceError
class Foo {}
```

- 不存在变量提升的原因是与继承有关，必须保证子类在父类之后定义
```js
{
  let Foo = class {};
  class Bar extends Foo {

  }
}
```
- 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。


### 私有方法和属性

- 现有的方法
```js
// 命名上加以区分
class Widget {
  // 公有方法
  foo (baz) {
    this._bar(baz);
  }
  // 私有方法
  _bar(baz) {
    return this.snaf = baz;
  }
}

// 将私有方法移出模块，因为模块内部的所有方法都是对外可见的
class Widget {
  foo (baz) {
    bar.call(this, baz);
  }
}

function bar(baz) {
  return this.snaf = baz;
}

// 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值
const bar = Symbol('bar');
const snaf = Symbol('snaf');

export default class myClass{
  // 公有方法
  foo(baz) {
    this[bar](baz);
  }
  // 私有方法
  [bar](baz) {
    return this[snaf] = baz;
  }
};
```

### 静态方法

- 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用

- 如果静态方法包含this关键字，这个this指的是类，而不是实例

- 静态方法可以和非静态方法重名

- 父类的静态方法，可以被子类继承

- 静态方法可以从super对象上调用的

## Class的继承

- Class 可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承

```js
class Point {

}
class ColorPoint extends Point {

}
```

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y);
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString()
  }
}
```

### super

- [参考资料](https://www.jb51.net/article/126399.htm)

- super只能在有继承的class的constructor中使用
- 作用：
  - 参数的入口，用来初始化父类的this
  - 将父类的方法和this继承过来
  - 可以当作函数使用来初始化父类，进行参数的传递，也可以当作对象使用，通过它来调用父组件的方法

- 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。
```js
class Point {

}
class ColorPoint extends Point {
  constructor() {}
}
const cp = new ColorPoint(); // ReferenceError
```

- 如果子类不写constructor方法，默认会调用super方法

- 可以使用`...args`来解构参数给super

- 在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例

- 父类的静态方法，也会被子类继承
```js
class A {
  static hello() {
    console.log('hello world');
  }
}

class B extends A {

}

B.hello() // hello world
```

- 判断一个类是否继承了另一个类
```js
Object.getPrototypeOf(ColorPoint) === Point;
```

### 类的prototype属性和__proto__属性

- `__proto__`属性是可以间接访问到，`prototype`属性是构造函数需要继承的

- 子类的__proto__属性，表示构造函数的继承，总是指向父类

- 子类的prototye属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性
```js
class A {

}
class B extends A {

}
B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
```

- 类的继承是按照下面的模式实现的
```js
class A {

}
class B {

}
// B的实例继承A的实例
Object.setPrototypeof(B.prototype, A.prototype);

// B继承A的静态属性
Object.setPrototypeOf(B, A);
const b = new B();
```

- `Object.setPrototypeOf`方法的实现
```js
Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```

## 修饰器

- 基本形式
```js
@test
class MyTest {

}
function test(target) {
  target.name = 'test';
}
console.log(MyTest.name);
```

- 多个参数
```js
@test(1, 2)
class MyTest {

}
function test(num1, num2) {
  return function (target) {
    target.num1 = num1;
    target.num2 = num2;
  }
}
```

- 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。意味着，修饰器能在编译阶段运行代码。本质就是编译时执行的函数

- 除了添加静态属性，还可以为添加实例属性
```js
function testable(target) {
  target.prototype.isTestable = true;
}
@testable
class MyTestableClass {}
const obj = new MyTestableClass();
obj.isTestable; // true
```

- 方法的修饰
```js
function readonly(target, name, descriptor) {
  descriptor.writable = false;
  return descriptor;
}
readonly(Person.prototype, 'name', descriptor);

// 类似于
// Object.defineProperty(Person.ptototype, 'name', descriptor);

class Person {
  @readonly
  name() { return `${this.first} ${this.last}`}
}
```

- 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行
```js
function dec(id) {
  console.log('evaluated', id);
  return (target, property, descriptor) => console.log('executed', id);
}
class Example {
  @dec(1)
  @dec(2)
  method(){}
}
// evaluated 1
// evaluated 2
// executed 2
// executed 1
```

- 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升，类是不会提升的，所以就没有这方面的问题

## Module语法

- CommonJS用于服务器，AMD用于浏览器

- `export default`导出文件的默认值，只能有一个

- `export default`后面不能变量声明语句

- `export default`命令的本质是将后面的值，赋给`default`变量

## Module的加载实现

- 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器卡死了，没有任何响应。
```html
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```

- `<script>`标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令

- `defer`和`async`的区别是：`defer`要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。

- `defer`是渲染完再执行，`async`是下载完就执行，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的

### ES6模块和CommonJS模块的差异

- CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用

- CommonJS模块是运行时加载，ES6模块是编译时输出接口

- CommonJS加载的是一个对象（module.exports属性），该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成

