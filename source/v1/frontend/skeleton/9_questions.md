---
title: 问题
order: 9
type: skeleton
---
## pwa中的service-worker
Service Worker 有以下功能和特性：
  - 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。
  - 一旦被 install，就永远存在，除非被手动 unregister，用到的时候可以直接唤醒，不用的时候自动睡眠
  - 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）
  - 离线内容开发者可控
  - 能向客户端推送消息
  - 不能直接操作 DOM
  - 必须在 HTTPS 环境下才能工作
  - 异步实现，内部大都是通过 Promise 实现

## 优化DNS解析
- 无线时代，网络稳定性差，应用流量敏感，APP和server之间每次HTTP请求都需要DNS解析

- 无线时代，DNS解析的时间不能忽略，一旦DNS被劫持，整个APP就挂了

### 不需要DNS解析的HTTP请求优化方案
1. 第一次访问时，先拉取server的ip-list保存到本地，访问过程与普通HTTP访问过程相同

1. 未来访问时，客户端直接使用ip-list中的IP来访问server，不再需要DNS

1. 如果DNS被劫持，直接尝试使用ip-list中的IP访问

### 更进一步的优化

1. 增加一个版本号，第一次拉取ip-list时，不但把ip-list放到APP本地，并把版本号也拿到。未来不用每次都拿ip-list，而是先拿版本号，如果版本号不变，直接使用本地的ip-list，只有版本号变化时，才需要重新拉取ip-list

1. 使用nginx不好做异构服务器的负载均衡，难以根据后端服务的处理能力来分配负载，使用ip-list，只要加上一个权重参数，就可以实现异构服务器的负载均衡：
192.168.1.1, 10
192.168.1.2, 10
192.168.1.3, 20

### 优势
- 不需要每次请求做DNS解析，节省时间

- 不需要每次请求做nginx转发，节省时间

- 不需要每次拉取拉取ip-list，节省流量

- DNS被劫持时仍可以使用本地ip

## 为何tcp/ip存在并发限制以及浏览器并发限制
- 首先，基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制和HTTP/1.1的Keep alive。所以，IE6/7在HTTP/1.1下的并发数量才2，这些都是针对同一个域名的，超过限制数目的请求会被阻塞。

- 随着技术的发展，负载均衡和各类NoSQL的大量应用，基本已经足以应对C10K的问题。但不是每个网站都懂得利用domain hash，也就是多域名来加速访问。因此，新的浏览器加大了并发数量的限制，但却控制在8以内。

- 由于 TCP 协议的限制，PC 端只有65536个端口可用以向外部发出连接，而操作系统对半开连接数也有限制以保护操作系统的 TCP\IP 协议栈资源不被迅速耗尽，因此浏览器不好发出太多的 TCP 连接，而是采取用完了之后再重复利用 TCP 连接或者干脆重新建立 TCP 连接的方法。

- 半开连接指的是 TCP 连接的一种状态，当客户端向服务器端发出一个 TCP 连接请求，在客户端还没收到服务器端的回应并发回一个确认的数据包时，这个 TCP 连接就是一个半开连接。若服务器到超时以后仍无响应，那么这个 TCP 连接就等于白费了，所以操作系统会本能的保护自己，限制 TCP 半开连接的总个数，以免有限的内核态内存空间被维护 TCP 连接所需的内存所浪费。

- 如果采用阻塞的套接字模型来建立连接，同时发出多个连接会导致浏览器不得不多开几个线程，而线程有时候算不得是轻量级资源，毕竟做一次上下文切换开销不小。

- 这是浏览器作为一个有良知的客户端在保护服务器。就像以太网的冲突检测机制，客户端在使用公共资源的时候必须要自行决定一个等待期。当超过2个客户端要使用公共资源时，强势的那个邪恶的客户端可能会导致弱势的客户端完全无法访问公共资源。从前迅雷被喷就是因为它不是一个有良知的客户端，它作为 HTTP 协议客户端没有考虑到服务器的压力，作为 BT 客户端没有考虑到自己回馈上传量的义务。

- 浏览器即使放弃保护自己，将所有请求一起发给服务器，也很可能会引发服务器的并发阈值控制而被BAN，而另外一个控制在8以内的原因也是keep alive技术的存在使得浏览器复用现有连接和服务器通信比创建新连接的性能要更好一些。所以，浏览器的并发数其实并不仅仅只是良知的要求，而是双方都需要保护自己的默契，并在可靠的情况下提供更好的性能。

- 按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 

- 解决方案是启用和主站不同的域名来放置静态资源，也就是cookie free。将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 

- 这也就衍生了domain hash技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。 

- 再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是css sprites的由来。全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 

- 由于css/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，js/css combine也就自然衍生了，同时也是minify、compress等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。

- 随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。  

- 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。   

- 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。

## [浏览器内核源码解析]

>[参考资料](https://www.cnblogs.com/lhb25/p/how-browsers-work.html)

## 什么是GUI
负责渲染浏览器界面的HTML元素，当界面需要重绘或由于某种操作引发回流时，该线程就会执行。在js引擎运行期间，GUI渲染线程都是处于挂起状态。

## js是如何操作dom的
dom有一套自己的规范可以提供给js但不限于js的语言来调用

## 为什么需要减少dom操作

> [开源中国](https://my.oschina.net/u/1580821/blog/744684)

会引起浏览器的重绘或者回流，耗费CPU和内存

## 可执行上下文

> [github - 概念](https://github.com/kuitos/kuitos.github.io/issues/18)

> [github - 实践](https://github.com/mqyqingfeng/Blog/issues/8)

### 变量对象（Variable，VO）
- 每一个执行上下文都会分配一个变量对象，变量对象的属性由变量和函数声明构成。在函数上下文情况下，参数列表也会被加入到变量对象中作为属性。变量对象和当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。
  - 函数声明会被加入到变量对象中，而函数表达式则不会

- 关于Global Object
  - 当js编译器开始执行的时候会初始化一个Global Object用于关联全局的作用域。对于全局环境而言，global object就是变量对象。变量对象对于程序而言是不可读的，只有编译器才有权访问变量对象。在浏览器端，global object被具象为window对象，也就是说 global object === window === 全局环境的变量对象。因此global object对于程序而言也是唯一可读的变量对象

### 活动对象（activation object）
- 当函数被激活，那么一个活动对象就会被创建并且分配给执行上下文。活动对象由特殊对象arguments初始化而成。随后，他被当作变量对象用于变量初始化。

### 作用域链（scope chain）
作用域链，它在解释器进入到一个执行环境时初始化完成并将其分配给当前执行环境。每个执行环境的作用域链由当前环境的变量对象及父级环境的作用域链构成

### this（上下文）
在js中，执行环境可以抽象为一个object，js解释器运行阶段还会维护一个环境栈，当执行流进入一个函数时，函数的环境就会被压入环境栈，当函数执行完后会将其环境弹出，并将控制权返回前一个执行环境。环境栈的顶端始终是当前正在执行的环境。

## TCP/IP原理

> 不多逼逼，直接阅读《图解http》

> [简书](https://www.jianshu.com/p/238b3fd525ec)

- 早在TCP/IP协议出现之前，国际标准化组织（ISO）就提出了开放系统互连（OSI）网络模型，为网络的设计、开发、编程、维护提供了便利的分而治之思想，其先进性、科学性、实用性不言而喻。

- TCP/IP协议不是单纯的两个协议，是一组不同层次上的多个协议组合，常称为TCP/IP协议簇。它也是互联网事实上的标准，为实现整个网络的互联提供指导。它的层次组合很难用OSI的七层模型来套用，它是OSI模型的浓缩，将原来的七层模型合并为四层协议的体系结构，自顶向下分别是应用层、传输层、网络层和网络接口层

![tcp-ip](../../images/tcp-ip.png)

## get和post区别，为什么get产生一个数据包，post有两个

> [w3c-区别](http://www.w3school.com.cn/tags/html_ref_httpmethods.asp)

> [知乎](https://www.zhihu.com/question/28586791)

## 负载均衡

> [知乎](https://www.zhihu.com/question/22610352)

## 浏览器三次握手和四次挥手

> [知乎](https://www.zhihu.com/question/67772889)

## 如何使浏览器更好的利用缓存

> [博客](https://www.renfei.org/blog/http-caching.html)

> [思否](https://segmentfault.com/a/1190000012573337)

## 包含块是个啥

> 不多逼逼《阅读css揭秘》

## 常规流，浮动，绝对定位等区别

> 不多逼逼《阅读css揭秘》

## 浮动元素不包含在常规流中

> 不多逼逼《阅读css揭秘》

## 相对定位，绝对定位，Fixed定位等区别

> 不多逼逼《阅读css揭秘》

## z-index的分层显示机制等

> 不多逼逼《阅读css揭秘》

## js是如何操纵dom树的

通过统一的api，其实非js也可以操作dom，只不过js和dom的配套比较成熟