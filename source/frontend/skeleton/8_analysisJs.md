---
title: JS引擎解析过程
order: 8
type: skeleton
---

## 解释阶段
**JS是解释型语言，所以它无需提前编译，而是由解释器实时运行。**
简述如下：
1. 读取代码，进行词法分析，然后将代码分解成词元（token）

1. 对词元进行语法分析，然后将代码整理成语法树

1. 使用翻译器，将代码转为字节码

1. 使用字节码解释器，将字节码转为机器码

最终浏览器执行的就是机器码
- 为了提高运行速度，现代浏览器一般采用即使编译：即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存，这样整个程序的运行速度都能得到显著提升。

- 不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（chromeV8）

总结：**核心的JIT编译器将源码编译成机器码运行。**

## 预处理阶段
正式执行JS前，还会有一个预处理阶段（变量提升，分号补全），这个阶段会做一些事情来确保JS可以正确执行：

- 分号补全：
  - 当有换行符，包括含有换行符的多行注释，并且下一个token没法跟前面的语法匹配时，会自动补分号

  - 当有`}`时，如果缺少分号，会补分号

  - 程序源代码结束时，如果缺少分号，会补分号

- 变量提升
  - 包括函数提升和变量提升，函数优先，如果函数名和变量名相同，还是函数优先，不管声明顺序

## 执行阶段
- 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）
  - 浏览器首次载入脚本，创建全局执行上下文，并压入执行栈栈顶，不可被弹出

  - 每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部

  - 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给剩下的堆栈

  - 依次执行，最终都会回到全局执行上下文

- VO（变量对象）和AO（活动对象）
  - VO是执行上下文的属性，只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）

  - 当函数被调用者激活，AO就创建了

  - 在函数上下文中：VO === AO

  - 在全局上下文中：VO === this === global

  - 总的来说，VO中会存放一些变量信息（如声明的变量，函数，arguments参数等等）

- 作用域链
  - 在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用，否则去它的父级作用域链中（__parent__）找，如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错

- this机制
  - this是执行上下文环境的一个属性，而不是某个变量对象的属性

  - this是没有一个类似搜寻变量的过程

  - 当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻

  - this的值只取决中进入上下文时的情况

## 回收机制
JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

一般来说，垃圾处理器有自己的回收策略。

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

常用的两种垃圾回收规则是：
- 标记清除：js用的
  - 遍历所有可访问的对象

  - 回收已不可访问的对象

  - 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。

  - 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。

  - 而当变量离开环境时，则将其标记为“离开环境”。

  - 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。

  - 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。

  - 而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

  - 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
  
- 引用计数
  - 跟踪记录每个值被引用的次数，当一个值被引用时，次数+1，减持时-1，下次垃圾回收器会回收次数为0的值的内存（当然了，容易出循环引用的bug）

### GC的缺陷
和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是引擎需要优化的点：避免GC造成的长时间停止响应。

GC优化策略
这里介绍常用到的：分代回收（Generation GC）
目的是通过区分“临时”与“持久”对象:
- 多回收“临时对象”区（young generation）

- 少回收“持久对象”区（tenured generation）

- 减少每次需遍历的对象，从而减少每次GC的耗时。