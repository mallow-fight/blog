---
title: 对比
order: 4
type: framework
---

[参考资料-Vue官网](https://cn.vuejs.org/v2/guide/comparison.html)

## Vue vs React

### 共同点
- 使用`Virtual DOM`
- 响应式和组件化的视图组件
- 将注意力集中保持在核心库，将其他功能如路由和全局状态管理交给相关的库

### 生态系统
- 目前`React`的生态系统比`Vue`庞大，`Vue`正在赶超

### 运行时性能&优化
#### 共同点
- 运行时非常快，性能好

#### Vue
- 组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了`shouldComponentUpdate`，并且没有上述子树问题限制
  - 这个特点使得开发者不再需要考虑此类优化，从而能够更好的专注于应用本身

#### React
- 当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树
  - 如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用`PureComponent`，或是手动实现`shouldComponentUpdate`方法。同时你可能会需要使用不可变的数据结构来使得组件更容易被优化
  - 使用`PureComponent`和`shouldComponentUpdate`时，需要保证该组件的整个子树的渲染输出都是由该组件的`props`所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致，这使得`React`中的组件优化伴随着相当的心智负担

### HTML&CSS

#### Vue
- 拥抱经典的`Web`技术，并在其上进行扩展
- 很多主流的`css-in-js`库也都支持`vue`（`styled-components-vue`和`vue-emotion`），设置样式的默认方法是单文件组件里类似`style`的标签
  - 通过`vue-loader`，可以使用任意的预处理器、后处理器，甚至深度集成在`css modules`中

- 也提供了渲染函数，支持`jsx`，但是默认推荐模版。任何合乎规范的`html`都是合法的`vue`模版，优势：
  - 模版比起`jsx`读写起来更自然
  - 基于`HTML`的模版使得将已有应用逐步迁移到`Vue`更容易
  - 更容易上手
  - 可以使用其他模版预处理器，比如：`Pug`、`less`、`jade`等
  - 具有`v-on`等修饰符，可以比`React`更为简洁的实现功能
  - 偏视图表现的使用模版，偏逻辑的使用`jsx`或渲染函数
  - `style`使用`scoped`属性绑定样式

#### React
- 一切都是`js`，不仅仅是`HTML`可以用`JSX`来表达，现在的潮流也越来越多地将`CSS`纳入到`js`中来处理
- 所有的组件的渲染功能都依靠`jsx`，`jsx`是使用`XML`语法来编写`js`的一种语法糖，优势：
  - 使用完整的编程语言`js`功能来构建你的视图页面。比如：临时变量、流程控制、直接引用当前`js`作用域中的值等
  - 开发工具对`jsx`的支持相比于现有可用的其他`Vue`模版还是比较先进的：`linting`、类型检查、编辑器的自动完成

- `CSS-in-JS`：引入了一个新的面向组件的样式范例，和普通的`css`撰写过程是有区别的，虽然在构建时将`css`提取到一个单独的样式表是支持的，但`bundle`里通常还是需要一个运行时程序来让这些样式生效。当你能够利用`js`灵活处理样式的同时，也需要权衡`bundle`的尺寸和运行时的开销

### 规模

#### 共同点
- 都提供了强大的路由来应对大型应用，提供了状态管理工具（`Redux`、`Vuex`）。

#### Vue
- 路由库和状态管理库都是由官方维护支持且和核心库同步更新
- `Vue-cli`
  - 支持配置
  - 提供了各种用途的模版
  - 能使用用户自建的模版构建项目，对企业环境下预先建立协议是特别有用的

#### React
- 路由库和状态管理库交给社区维护，创建了一个更分散的生态系统，相对的，生态系统更加繁荣
- `create-react-app`
  - 不允许在项目生成时进行任何配置
  - 只提供一个构建单页面应用的单一模版
  - 不能使用用户自建的模版构建项目
  - 故意设计这些限制，如果你的项目需求非常简单，就不需要自定义生成过程，你能把它作为一个依赖来更新

### 向下扩展
#### Vue
- 容易上手，可使用外链脚本

#### React
- 需要知道`jsx`和`es2015`，这个也不难

### 原生渲染
#### Vue
- `Weex`

#### React
- `React Native`

## Vue vs AngularJS
### 共同点
- 一些语法相似（`v-if vs ng-if`）

### 复杂性
`Vue`比`Angular`简单的多

### 灵活性和模块化
`Vue`更加灵活开放，不用在任何时候都必须遵循`AngularJS`制定的规则，`Vue`能适用于各种项目，决定权在你手中

### 数据绑定
`AngularJS`使用双向绑定，`Vue`在不同组件间强制使用单向数据流，使得应用中的数据流更加清晰易懂

### 指令和组件
在 `Vue` 中指令和组件分得更清晰。指令只封装 `DOM` 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。在 `AngularJS` 中，每件事都由指令来做，而组件只是一种特殊的指令。

### 运行时性能

#### Vue
- 有更好的性能，非常容易优化，不使用脏检查
- 基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系

#### AngularJS
- 当`watcher`越来越多时会变得越来越慢，因为作用域每一次变化，所有`watcher`都要重新计算，如果一些`watcher`触发另一个更新，脏检查循环可能要运行多次。用户常常需要使用深奥的计数来解决脏检查循环的问题，没有简单的方法来优化有大量`watcher`的作用域
- `Angular`和`Vue`用相似的设计解决了一些`AngularJS`中存在的问题

## Vue vs Angular
### 相同点
- 运行速度很快

### Angular
- `ts`
- 体积大、大量`api`、对新手不友好
- 针对大型的复杂应用

### Vue
- 体积小、灵活

## Knockout
- 支持`IE6`

## 原理

### vue
#### 结合生命周期理解
> [Vue生命周期](./vue.html#数据和方法)

#### 深入响应式原理
- 数据模型的改变会更新视图，而数据模型仅仅只是普通的js对象，这使得状态管理变得很简单直接。

- 如何追踪变化：当你把一个普通的js对象传给vue实例的data选项，Vue将遍历此对象所有的属性，并使用`Object.defineProperty`(es5中无法shim的特性，故Vue不支持ie8以及更低版本浏览器)把这些属性全部转为`getter/setter`

- 这些属性对用户来说是不可见的，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化

- 每个组件实例都有相应的`watcher`实例对象，它会在组件渲染过程中把属性记录为依赖，之后当依赖项的`setter`被调用时，会通知`watcher`重新计算，从而使它关联的组件得以更新

![data](../../images/data.png)

## 检测变化的注意事项

受现代`js`的限制（以及废弃`Object.observe`），`Vue`不能检测到对象属性的添加或删除。由于 `Vue` 会在初始化实例时对属性执行 `getter/setter` 转化过程，所以属性必须在 `data` 对象上存在才能让 `Vue` 转换它，这样才能让它是响应的。

解决方式：
1. Vue.set(object, key, value)

1. this.$set(object, key, value)

1. 创建一个新的对象：
  - this.someObject = Object.assign({}, this.someObject, {a: 1, b: 2})

1. 针对数组，不能检测以下变动的数组：

  - 当你利用索引直接设置一个项时：
    - `Vue.set(vm.array, index, newValue)` 

    - `vm.items.splice(index, 1, newValue)` 

    - `this.$set`

  - 当你修改数组的长度时：
    - `splice`

  - 如果数组中某项是对象，设置对象的时
    - `this.items = [].concat(this.items)`

#### 异步更新队列

`Vue` 异步执行 `DOM` 更新。只要观察到数据变化，`Vue` 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 `watcher` 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 `DOM` 操作上非常重要。然后，在下一个的事件循环“`tick`”中，`Vue` 刷新队列并执行实际 (已去重的) 工作。`Vue` 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MessageChannel`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。例：

```html
<div id="example">{{message}}</div>
<script>
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'new message' // 更改数据
vm.$el.textContent === 'new message' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
})
</script>
```

### react
#### 虚拟dom

- 一种编程概念，是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与“真实”的DOM保持同步。这个过程被称为和解。

- 这种编程方法使用了React的声明式API：你需要告诉React你想让视图处于什么状态，React则负责确保DOM与该状态相匹配。因此你在构建你的应用时不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。

- 由于“虚拟DOM”更像一种模式而不是特定的技术，有时候我们也会用它表示其他的意思。在React的世界中，由于 “虚拟DOM” 和 React元素 都是用于表示视图的对象，因此常常被关联在一起。然而React也使用被称为“fibers”的对象来存放组件树的附加信息。在React中，它们也被认为是“虚拟DOM”实现的一部分。

### angular
- 使用脏检查

- 页面庞大时需要调用apply()方法手动触发页面脏检查

#### 脏检查
> [知乎](https://www.zhihu.com/question/43470158)

DI / 双向数据绑定中：
- 用户 -> 内存 ：
  - 浏览器提供有User Event触发事件的API，如click，change...等等等；
  
- 内存 -> 用户：
  - 浏览器并没有提供数据监测的API，故任何内存数据变动（定时、异步请求、事件触发...导致的数据变动）都无法被Listen，自然也就没办法再处理callback了；

  - 但我们可以基于这些大部分能够产生数据变动的事件进行封装（如：click、mouse-enter、Timeout...），在每次事件发生后，执行完事件后，检查一遍数据的变化，如果数据和上次的值有变化，则执行这个值（注册时）对应的callback（框架中），这个callback可能是view层的一个数据展现，也可能是一段处理function；

  - 在检查数据变化的时候，由于你并不知道这个事件是对哪些数据进行了更改，以及这个事件有可能造成事件之外的其他任何地方的数据更改，所以必须进行一次大检查，将所有“注册”过的值全部检查一遍，一次检查称为一个周期，每次最少检查两遍，因为第二遍用来确认，前一遍的变动中是否有数据的变动，导致了其他数据的变动，如果第二次有变动的话，会再执行一遍，直到最后两次完全一致，则停止检查（其实就是个（递归（遍历））的过程），考虑到内存的消耗和死循环的风险，脏检查每个周期最多递归执行10遍，所以在程序结构设计中，尽量避免数据与数据之间的紧耦合；

  - 所以我们看到的
    - ng-click，ng-change，ng-blur...就是对各类用户事件的封装

    - $timeout，$http，$window，$location...就是对各种JS/API事件的封装

    - ng-model，以及控制器中的数据，就是对值的“注册”

    - $scope 本质是一个总的事件逻辑的封装容器，同时抽象为数据载体

  - 实质上数据都存在于浏览器堆内存中
    - $scope.apply() & $scope.digest() 即Angular中的“数据大检查”的function

    - 所以如果我们使用了非Angular封装的事件改编数据时，要手动执行一次大检查
    
    - 由于Angular这种脏检查的方法效率不高，如果一个页面绑定的view超过2000个，就可能存在比较明显的性能问题，官方称之为“脏检查”