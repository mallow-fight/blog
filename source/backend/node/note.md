---
title: 笔记
order: 1
type: node
---

## 原理
- 基于V8的javascript运行时，事件驱动、非阻塞、轻量、高效。
- 服务端js解释器，用于方便的搭建响应速度块、易于扩展的网络应用。node.js使用事件驱动，非阻塞I/O模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。
- 一个可以让js运行在浏览器之外的平台。实现了诸如文件系统、模块、包、操作系统API、网络通信等Core JavaScript没有或者不完善的功能。

### 基础架构

示意图：
![node](../../images/node.png)
- 最底层是Node.js依赖的各种库，有V8、libuv等
- 中间层是各种Binding，也就是胶水代码
- 最上层是应用代码，可使用Node.js的各种API

![node_stucture](../../images/node_stucture.png)
- Node.js 标准库，这部分是由 Javascript 编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。
- Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。实现在 node.cc
- 这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。
    - V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 Javascript 的关键，它为 - - - Javascript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。
    - Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。
    - C-ares：提供了异步处理 DNS 相关的能力。
    - http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。

#### V8
谷歌开源的高性能js引擎，将js代码转换为机器码，然后执行，因此速度非常快。它用C++开发，谷歌的Chrome浏览器使用的就是V8引擎。Node在服务器上使用重建过后的V8引擎。

#### libuv
用C语言开发，内部管理者一个线程池。在此基础上，提供事件循环、异步网络I/O、文件系统I/O等能力。
Libuv 是 Node.js 关键的一个组成部分，它为上层的 Node.js 提供了统一的 API 调用，使其不用考虑平台差距，隐藏了底层实现。

具体它能做什么，官网的这张图体现的很好：
![libuv](../../images/libuv.png)

可以看出，它是一个对开发者友好的工具集，包含定时器，非阻塞的网络 I/O，异步文件系统访问，子进程等功能。它封装了 Libev、Libeio 以及 IOCP，保证了跨平台的通用性。

我们只要先知道它本身是异步和事件驱动的，记住这点，下面的问题就有了答案，我们一一来看。

#### 与操作系统的交互

举个简单的例子，我们想要打开一个文件，并进行一些操作，可以写下面这样一段代码：

```js
var fs = require('fs');
fs.open('./test.txt', "w", function(err, fd) {
	//..do something
});
```

这段代码的调用过程大致可描述为：lib/fs.js → src/node_file.cc → uv_fs

Node.js 深入浅出上的一幅图：
![node_oprate](../../images/node_oprate.png)

具体来说，当我们调用 fs.open 时，Node.js 通过 process.binding 调用 C/C++ 层面的 Open 函数，然后通过它调用 Libuv 中的具体方法 uv_fs_open，最后执行的结果通过回调的方式传回，完成流程。在图中，可以看到平台判断的流程，需要说明的是，这一步是在编译的时候已经决定好的，并不是在运行时中。

总体来说，我们在 Javascript 中调用的方法，最终都会通过 process.binding 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。

通过这个过程，我们可以发现，实际上，Node.js 虽然说是用的 Javascript，但只是在开发时使用 Javascript 的语法来编写程序。真正的执行过程还是由 V8 将 Javascript 解释，然后由 C/C++ 来执行真正的系统调用，所以并不需要过分担心 Javascript 执行效率的问题。可以看出，Node.js 并不是一门语言，而是一个 平台，这点一定要分清楚。

#### 异步、非阻塞 I/O
通过上文，我们了解到，真正执行系统调用的其实是 Libuv。之前我们提到，Libuv 本身就是异步和事件驱动的，所以，当我们将 I/O 操作的请求传达给 Libuv 之后，Libuv 开启线程来执行这次 I/O 调用，并在执行完成后，传回给 Javascript 进行后续处理。

这里面的 I/O 包括文件 I/O 和 网络 I/O。两者的底层执行略有不同。从上面的 Libuv 官网的图中，我们可以看到，文件 I/O，DNS 等操作，都是依托线程池（Thread Pool）来实现的。而网络 I/O 这一大类，包括：TCP、UDP、TTY 等，是由 epoll、IOCP、kqueue 来具体实现的。

总结来说，一个异步 I/O 的大致流程如下：

发起 I/O 调用

用户通过 Javascript 代码调用 Node 核心模块，将参数和回调函数传入到核心模块；
Node 核心模块会将传入的参数和回调函数封装成一个请求对象；
将这个请求对象推入到 I/O 线程池等待执行；
Javascript 发起的异步调用结束，Javascript 线程继续执行后续操作。
执行回调

I/O 操作完成后，会将结果储存到请求对象的 result 属性上，并发出操作完成的通知；
每次事件循环时会检查是否有完成的 I/O 操作，如果有就将请求对象加入到 I/O 观察者队列中，之后当做事件处理；
处理 I/O 观察者事件时，会取出之前封装在请求对象中的回调函数，执行这个回调函数，并将 result 当参数，以完成 Javascript 回调的目的。

#### 其它
如c-ares、crypto（OpenSSL）、http-parser以及zlib。这些依赖提供了对系统底层功能的访问，包括网络、压缩、加密等。

- Node.js底层的依赖库，有的以C语言开发，有的以C++语言开发，如何让应用代码（js）能够与这些底层库相互调用呢，这就需要中间层Binding来完成。Binding是一些胶水代码，能够把不同语言绑定在一起使其能够互相沟通。在node.js中，binding就是把node.js那些用C/C++写的库接口暴露给js环境。
- 中间层中，除了Binding，还有Addon。Binding仅桥接Node.js核心的一些依赖，如果你想在应用程序中包含其他第三方或者你自己的C/C++库的话，需要自己完成这部分的胶水代码。你写的这部分胶水代码就称为Addon。本质上都是完成桥接的作用，使得应用和底层库能够互通。
- 应用层就是我们开发的应用、npm安装的包都运行在这里。

### 事件循环

#### 示意图
![node-event](../../images/node-event.png)

#### 原理
- 一个Node.js应用启动时，V8引擎会执行你写的应用代码，保持一份观察者（注册在事件上的回调函数）列表。当事件发生时，它的回调函数会被加进一个事件队列。只要这个队列还有等待执行的回调函数，事件循环就会持续把回调函数从队列中拿出并执行。
- 在回调函数执行过程中，所有的I/O请求都会转发给工作线程处理。libuv维持着一个线程池，包含四个工作流程（默认值，可配置）。文件系统I/O请求和DNS相关请求都会放进这个线程池处理；其它的请求，如网络、平台特性相关的请求会分发给相应的系统处理单元进行处理。
- 安排给线程池的这些I/O操作由Node.js的底层库执行，完成之后触发相应事件，对应的事件回调函数会被放入事件队列，等待执行后序操作。这就是一个事件在Node.js中执行的整个生命周期。
- 我们只知道Node.js有事件循环，但是不知道每次循环何时开始、何时结束。事件循环阶段图：
![node-event-loop](../../images/node-event-loop.png)
> 每一个方块，在事件循环中被称为一个阶段。
- 每个阶段都有自己独有的一个用于执行回调函数的FIFO（先进先出）队列。当事件循环进入一个指定阶段时，会执行队列中的回调函数，当队列中已经被清空或执行的回调函数个数达到系统最大限制时，事件循环会进入下一个阶段。
- 图中的六个阶段分别为：
    - timers：该阶段由`setTimeout()`和`setInterval()`设置的回调函数。
    - I/O callbacks：执行除了close回调、timers以及`setImmediate()`设置的回调以外的几乎所有的回调。
    - idle，prepare：仅供内部使用。
    - poll：检索新的I/O事件，在适当的时候Node.js会阻塞等待。
    - check：执行`setImmediate()`设置的回调。
    - close callbacks：执行关闭回调，`socket.on('close', ...)`。

### 作用
- Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java™ 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。这个不同的架构承载的并发数量是不一致的。 
- 而Node的出现就是为了解决这个问题：更改连接到服务器的方式。在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。

使用为网络而生的Node.js，你可以轻易的实现：
- 具有复杂逻辑的网站
- 基于社交网络的大规模的web应用
- web socket 服务器
- TCP/UDP 套接字应用程序
- 命令行工具
- 交互式终端程序
- 带有图形用户界面的本地应用程序
- 单元测试工具
- 客户端js编译器

### 事件驱动
在我们使用Java，PHP等语言实现编程的时候，我们面向对象编程是完美的编程设计，这使得他们对其他编程方法不屑一顾。却不知大名鼎鼎Node使用的却是事件驱动编程的思想。那什么是事件驱动编程。 
事件驱动编程，为需要处理的事件编写相应的事件处理程序。代码在事件发生时执行。 
为需要处理的事件编写相应的事件处理程序。要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu。 
即：事件源 -> 事件对象 -> 事件处理程序
事件驱动模型主要包含3个对象：事件源、事件和事件处理程序。

事件源：产生事件的地方(html元素)
事件：点击/鼠标操作/键盘操作等等
事件对象：当某个事件发生时，可能会产生一个事件对象，该时间对象会封装好该时间的信息，传递给事件处理程序
事件处理程序：响应用户事件的代码 
其实我们使用的window系统也算得上是事件驱动了。我们来看一个简单的事例：监听鼠标点击事件，并能够显示鼠标点击的位置x,y。

当我们搜索Node.js时，夺眶而出的关键字就是 “单线程，异步I/O，事件驱动”，应用程序的请求过程可以分为俩个部分：CPU运算和I/O读写，CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务。 
所以I/O才是应用程序的瓶颈所在，在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。 
但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。但操作系统在内核切换线程的同时也要切换线程的上线文，当线程数量过多时，时间将会被消耗在上下文切换中。所以在大并发时，多线程结构还是无法做到强大的伸缩性。 
那么是否可以另辟蹊径呢？！我们先来看看单线程，《深入浅出Node》一书提到 “单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图： 
![node_IO](../../images/node_IO.png)

Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。 
I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。 
在node.js中，事件主要来源于网络请求，文件I/O等，根据事件的不同对观察者进行了分类，有文件I/O观察者，网络I/O观察者。事件驱动是一个典型的生产者/消费者模型，请求到达观察者那里，事件循环从观察者进行消费，主线程就可以马不停蹄的只关注业务不用再去进行I/O等待。

这里面涉及到了 Libuv 本身的一个设计理念，事件循环（Event Loop），它是一个类似于 while true 的无限循环，其核心函数是 uv_run，下文会用到。

从这里，我们可以看到，我们其实对 Node.js 的单线程一直有个误会。事实上，它的单线程指的是自身 Javascript 运行环境的单线程，Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因，两者并不冲突。


## 登录授权的完整流程
- 登录流程
    - 无账号，去注册
    - 有账号，去登录
- 授权
    - 前端视觉限制（仅限于对内平台）
    - cookie（可以对外）
    - 携带token的请求头（可以对外）
    - 如果是单页应用可以放在state中

## exports的用法

### 当成一个对象使用

```js
// test.js
exports.test1 = 'i am test1'
exports.test2 = () => exports.test3 = 'i am test3'
```

```js
const test = require('test.js')
console.log(test) // {test1: 'i am test1', test2: [function]}
console.log(test.test2()) // i am test3
console.log(test) // {test1: 'i am test1', test2: [function], test3: 'i am test3'}
```

## 如何使用node注册终端指令

- [阮一峰](https://www.npmjs.com/package/v8-compile-cache)