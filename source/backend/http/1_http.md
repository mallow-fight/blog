---
title: http
order: 1
type: http
---

## 定义

- 用于传输如HTML超媒体文档的应用层协议

- 用于web浏览器和web服务器之间的通信

- 遵循经典的客户端-服务端模型

- 客户端打开一个连接发出请求，然后等待这个连接收到服务器响应

- 无状态协议，服务器不会在两个请求之间保留任何数据和状态

- 通常用于TCP/IP层，但可以在任何可靠的传输层上使用，如一个不会静默丢失消息的协议：UDP

- 是可扩展协议

## 概述

- web上进行数据交换的基础

- client-server协议

- 请求通常是浏览器这样的接受方发起的

- 完整的web文档由不同的子文档拼接而成

- 客户端和服务端通过交换各自的消息进行交互

  - 像浏览器这样的客户端发出的消息叫requests
  
  - 被服务端回应的消息叫responses

## 组件系统

1. 客户端：user-agent

1. web服务端

1. 代理（proxies）

## 本质

1. http是简单的

1. http是可扩展的

1. http是无状态，有会话的

1. http连接

## 控制

1. 缓存

1. 开放同源限制

1. 认证

1. 代理和隧道

1. 会话

## 流

当客户端想和服务端进行信息交互时（服务端指的是最终服务器，或者是一个中间代理商 ），过程表现为下面几步：

1. 打开一个tcp连接

1. 发送一个http报文

1. 读取服务端返回的报文信息

1. 关闭连接或为后续请求重用连接

## 报文

- HTTP/1.1以及更早的HTTP协议报文都是语义可读的。

- 在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。

- 帧允许实现很多优化，比如报文头部的压缩和复用。即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，客户端会重组原始HTTP/1.1请求。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效。

- 有两种HTTP报文的类型，请求与回应，每种都有其特定的格式。

## 请求

- 一个HTTP的method，经常是由一个动词像GET, POST 或者一个名词像OPTIONS，HEAD来定义客户端的动作行为。通常客户端的操作都是获取资源（GET方法）或者发送HTML form表单值（POST方法），虽然在一些情况下也会有其他操作。

- 要获取的资源的路径，通常是上下文中就很明显的元素资源的URL，它没有protocol （http://），domain（developer.mozilla.org），或是TCP的port（HTTP一般在80端口）。

- HTTP协议版本号。

- 为服务端表达其他信息的可选头部headers。

- 对于一些像POST这样的方法，报文的body就包含了发送的资源，这与回应报文的body类似。

### 类型

- 简单请求

  - 请求方法是以下三种方法之一：

      - head

      - get

      - post

  - HTTP的头信息不超出以下几种字段：

      - Accept

      - Accept-Language

      - Content-Language

      - Last-Event-ID

      - Content-Type：只限于三个值

        - application/x-www-form-urlencoded

        - multipart/form-data

        - text/plain

- 非简单请求

  - 对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

  - 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

  - 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。


## 回应

- HTTP协议版本号。

- 一个状态码（status code），来告知对应请求执行成功或失败，以及失败的原因。

- 一个状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。

- HTTP headers，与请求头部类似。

- 可选项，比起请求报文，响应报文中更常见地包含获取的资源body。

## 发展

### 万维网的发明

- 一个用来表示超文本文档的文本格式，超文本标记语言（HTML）。

- 一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。

- 一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 WorldWideWeb。

- 一个服务器用于提供可访问的文档，即 http 的前身。

### http/0.9 - 单行协议

- 请求由单行指令构成，以唯一可用方法get开头，其后跟目标资源路径

### http/1.0 - 构建可扩展性

- 协议版本信息会随着每个请求发送

- 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败

- 引入了http头的概念，无论对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性

- 在新http头的帮助下，具备了传输除纯文本html文件以外类型文档的能力

### http/1.1 - 标准化的协议

- 连接可以复用，节省了多次打开tcp连接加载网页文档资源的时间

- 增加流水线操作，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟

- 支持响应分块

- 引入额外的缓存控制机制

- 引入内容协商机制，包括语言，编码，类型等，允许客户端和服务端之间约定以最合适的内容进行交换

- host头，能够使不同域名配置在同一个ip地址服务器上

### 超过15年的扩展

1. http用于安全运输（ssl -> tls）

1. http用于复杂应用

1. 放松web的安全模型

### http/2 - 更优异的表现

**与http/1.1的不同：**

1. http2是二进制协议而不是文本协议。不再可读和无障碍的手动创建，改善的优化技术现在可被实施。

1. 这是一个复用协议。并行的请求能在同一个链接中处理，移除了http/1.x中顺序和阻塞的约束。

1. 压缩了headers。headers在一系列请求中常常是类似的，移除了重复和传输重复数据的成本。

1. 允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

## http消息

**http消息是服务器和客户端之间交换数据的方式。**

**两种类型消息：**

- 请求：由客户端发送用来触发一个服务器上的动作

- 响应：来自服务器的应答

- http/2二进制框架机制被设计为不需要改动任何api或配置文件即可应用：它大体上对用户是透明的。

**http请求和响应具有相似的结构：**

1. 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。

1. 一个可选的http头集合指明请求或描述消息正文。

1. 一个空行指示所有关于请求的元数据已经发送完毕。

1. 一个可选的包含请求相关数据的正文

## http请求

### 起始行

**http请求是由客户端发出的消息，用来使服务器执行动作。**

1. 一个http方法，描述要执行的动作。

1. 请求目标，以请求的环境为特征，通常是一个url。

### headers

**形式：健值对**

1. general headers：适用于整个报文

1. request headers：进一步定义，给定上下文，进行有条件的限制。

1. entity headers：请求的body

### body

- post请求或者html表单数据

- single-resource bodies

- multiple-resource bodies

## http响应

### 状态行

**响应的起始行被称为状态行，example: HTTP/1.1 404 Not Found, contains：**

1. the protocal version, usually http/1.1

1. a status code, indicating success or failure of request. like: 200, 204, or 302

1. a status text. a brief description of the status code to help a human understand the http message.

### headers and body is just like request

## 内网

**tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下**

  - 10.0.0.0/8：10.0.0.0～10.255.255.255 

  - 172.16.0.0/12：172.16.0.0～172.31.255.255 

  - 192.168.0.0/16：192.168.0.0～192.168.255.255

## 状态码

> [更详细的状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

- **100(continue)——请求已被服务器接收，继续处理**

  - 101(switching protocal): 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议

  - 102(processing): 此代码表示服务器已收到并正在处理该请求，但没有响应可用

- **200(ok)成功——请求已成功被服务器接收、理解、并接受**

  - 201(created): 该请求已成功，并因此创建了一个新的资源。这通常是在PUT请求之后发送的响应。
  
  - 202(accepted): 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。

  - 203 Non-Authoritative Information: 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。

  - **204 No Content: 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。**

  - 205 Reset Content: 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

  - 206 Partial Content: 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。

  - 207 Multi-Status (WebDAV): 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。

  - 208 Multi-Status (WebDAV): 在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。

  - 226 IM Used (HTTP Delta encoding): 服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。

- **300 Multiple Choice: 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。**

  - 301 Moved Permanently: 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。

  - 302 Found: 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

  - 303 See Other: 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。
  
  - **304 Not Modified: 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。**

  - **305 Use Proxy :被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。**

  - 306 unused: 在最新版的规范中，306 状态码已经不再被使用。

  - 307 Temporary Redirect: 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

  - 308 Permanent Redirect: 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。

- **400 Bad Request: 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。**

  - **401 Unauthorized: 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。**

  - 402 Payment Required: 此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。

  - **403 Forbidden: 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。**

  - **404 Not Found: 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。**

  - **405 Method Not Allowed: 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。**

  - 406 Not Acceptable: 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。

  - 407 Proxy Authentication Required: 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。
  
  - 408 Request Timeout: 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。

  - 409 Conflict: 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。

  - 410 Gone: 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。

  - 411 Length Required: 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。

  - 412 Precondition Failed: 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。

  - 413 Payload Too Large: 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。

  - 414 URI Too Long: 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。

  - 415 Unsupported Media Type: 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。

  - 416 Requested Range Not Satisfiable: 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。

  - 417 Expectation Failed: 此响应代码意味着服务器无法满足 期望 请求标头字段指示的期望值。

  - 418 I'm a teapot: 服务器拒绝尝试用 “茶壶冲泡咖啡”。

  - 412 Precondition Failed: 该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。

  - 422 Unprocessable Entity (WebDAV): 请求格式良好，但由于语义错误而无法遵循。

  - 423 Locked (WebDAV):  正在访问的资源被锁定。

  - 424 Failed Dependency (WebDAV): 由于先前的请求失败，所以此次请求失败。

  - 426 Upgrade Required: 服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 Upgrade 头以指示所需的协议。

  - 428 Precondition Required: 原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。

  - 429 Too Many Requests: 用户在给定的时间内发送了太多请求（“限制请求速率”）。

  - 431 Request Header Fields Too Large: 服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。

  - 451 Unavailable For Legal Reasons: 用户请求非法资源，例如：由政府审查的网页。

- **500 Internal Server Error: 服务器遇到了不知道如何处理的情况。**

  - **501 Not Implemented: 此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。**

  - **502 Bad Gateway: 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。**

  - **503 Service Unavailable: 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。**

  - **504 Gateway Timeout: 当服务器作为网关，不能及时得到响应时返回此错误代码。**

  - 505 HTTP Version Not Supported: 服务器不支持请求中所使用的HTTP协议版本。

  - 506 Variant Also Negotiates: 服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。

  - 507 Insufficient Storage: 服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。

  - 508 Loop Detected (WebDAV): The server detected an infinite loop while processing the request.服务器在处理请求时检测到无限循环。

  - 510 Not Extended: 服务器需要对请求进一步扩展才能实现它。

  - 511 Network Authentication Required: 511 状态码指示客户端需要进行身份验证才能获得网络访问权限。

## http-connection

**in http/1.x, there are several models: short-lived connections, persistent connections, and http pipelining.**

## http-session

### establishing a connection

**In client-server protocols, it is client which establishes the connection.means initiating a connection in the underlying transport layer, usually this is TCP(the default port is 80).**

### sending a client request

**once the connection is established, the user-agent can send the request(a user-agent is typically a web browser).A client request consists of text directives, separated by CRLF(回车换行)**

**第一行包括请求方法及请求参数：**

- 文档路径，不包括协议和域名的绝对路径 URL

- 使用的 HTTP 协议版本

- 接下来的行每一行都表示一个 HTTP 首部，为服务器提供关于所需数据的信息（例如语言，或 MIME 类型），或是一些改变请求行为的数据（例如当数据已经被缓存，就不再应答）。这些 HTTP 首部组成以一个空行结束的一个块。

- 最后一块是可选数据块，包含更多数据，主要被 POST 方法所使用。

### structure of a server response

**当收到用户代理发送的请求后，Web 服务器就会处理它，并最终送回一个响应。与客户端请求很类似，服务器响应由一系列文本指令组成, 并使用 CRLF 分隔，它们被划分为三个不同的块：**

- 第一行是 状态行，包括使用的 HTTP 协议版本，状态码和一个状态描述（可读描述文本）。

- 接下来每一行都表示一个 HTTP 首部，为客户端提供关于所发送数据的一些信息（如数据大小，使用的压缩算法，缓存指示）。与客户端请求的头部块类似，这些 HTTP 首部组成一个块，并以一个空行结束。

- 最后一块是数据块，包含了响应的数据 （如果有的话）。
